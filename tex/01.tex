\chapter{Основные понятия}

\section{Понятие языка программирования}

Современный мир уже немыслим без вычислительных машин. Они проникли
практически во все сферы деятельности человека: от огромных
автоматических заводов до бытовой техники. Та скорость
научно-технического прогресса, которой достигло человечество, была бы
невозможна без компьютеров, то есть устройств, способных производить
вычисления по заданному заранее сценарию —
\Term{Программа}{программе}.

Наличие программы является принципиальным отличием компьютеров от,
например, механического арифмометра. Арифмометр может выполнить лишь
одно арифметическое действие за один раз. Как правило, этого
недостаточно для решения стоящей перед человеком задачи. Компьютер же
способен выполнить все требуемые расчёты без вмешательства
человека. Это значительно повышает уровень автоматизации вычислений.

Более того, расчёт по программе не требует жёсткого задания
последовательности действий. Компьютер может решать, какая операция
будет следующей, в зависимости от результатов предыдущих вычислений,
если подобное предусмотрено программой.

Цель создания и использования компьютеров — решение задач, возникающих
перед человеком. Но без программы, описывающей это решение, компьютер
был бы бесполезен. Компьютер же выступает в роли устройства,
исполняющего предусмотренные программой действия.

Современные вычислительные машины, как правило, представляют собой
электронные приборы. Поэтому когда говорят о вычислительных
устройствах, обычно имеют в виду \Term{Машина!электронная
  вычислительная}{электронные вычислительные машины} (ЭВМ).  Кроме
того, часто употребляется термин компьютер (от англ. computer —
вычислитель). Существуют и неэлектронные компьютеры: механические,
оптические, биологические.

Подавляющее большинство компьютеров строится из электронных
компонентов, так как механические и электромеханические вычислительные
устройства не могут достичь столь же высокой скорости вычислений,
громоздки и менее надёжны.

Современные технологии позволяют создавать микроэлектромеханические
системы (МЭМС) размером порядка 1~мкм, но это на два порядка больше,
чем размеры электронных компонентов микросхем, которые изготавливаются
по технологическому процессу 22~нм. Кроме того, скорость
распространения сигналов в электронных схемах равна скорости света,
чего невозможно добиться в механической системе.

С другой стороны, существуют принципиальные ограничения на
быстродействие и уменьшение размеров микросхем, поэтому в последнее
время особое внимание уделяют эффективности вычислений. В частности,
стремятся при возможности выполнять различные команды не
последовательно, а одновременно на нескольких вычислительных
устройствах.

Оптические и квантовые компьютеры пока существуют в виде прототипов и
ещё не получили широкого распространения. Более того, квантовые
компьютеры основаны на совершенно иных принципах вычислений.

Таким образом, можно дать следующее определение компьютера.

\begin{defn}
  \Term{Компьютер}{Компьютер} — комплекс технических и программных
  средств, предназначенный для автоматизации подготовки и решения
  задач пользователя.
\end{defn}

Как следует из приведённого выше определения, работа компьютера
обеспечивается двумя составляющими:
\Term{Средства!технические}{техническими средствами} (hardware) и
\Term{Обеспечение!программное}{программным обеспечением} (software).

Технические средства (или \Term{Обеспечение!аппаратное}{аппаратное
  обеспечение}) — это оборудование, предназначенное для выполнения
простейших вычислительных операций. Его работа заключается в
выполнении перечня команд, решающих ту или иную задачу.

Существует множество подходов к построению аппаратного
обеспечения. Они зависят как от физических принципов, на которых
основана работа компьютера, так и от требований к его надёжности,
быстродействию, энергопотреблению.

Набор базовых принципов, на которых основано функционирование
компьютера, называется \Term{Архитектура компьютера}{архитектурой}. В
настоящее время существует большое количество используемых на практике
различных архитектур, но подавляющее большинство из них являются
развитием одной следующих:

\begin{itemize}
\item \Term{Архитектура!принстонская}{принстонской}
  (\Term{Архитектура!фон Неймана}{архитектуры фон Неймана}) и
\item \Term{Архитектура!гарвардская}{гарвардской}.
\end{itemize}

В персональных компьютерах обычно используется архитектура фон
Неймана, а гарвардская чаще применяется в микроконтроллерах —
микрокомпьютерах, изготовленных в виде одной микросхемы и встраиваемых
в различные устройства.

Архитектура фон Неймана основывается на следующих принципах, которые
были сформулированы ещё в 1946 году:

\begin{enumerate}
\item \Term{Принцип!двоичного кодирования}{Принцип двоичного
  кодирования.} Вся информация, используемая при вычислених (и
  программа, и данные) кодируется в виде набора чисел, представленных
  в двоичной системе. Информация хранится в специальном устройстве —
  \Term{Память}{памяти}. Выбор именно двоичной системы обусловлен
  техническими особенностями построения компьютеров. Хотя существовали
  ЭВМ, использующие десятичную и даже троичную системы.
\item \Term{Принцип!однородности памяти}{Принцип однородности памяти.}
  Программы и данные хранятся в одной и той же памяти.
\item \Term{Принцип!адресуемости памяти}{Принцип адресуемости памяти.}
  Память представляет собой набор пронумерованных ячеек. При этом
  каждая из ячеек доступна в любой момент времени.
\item \Term{Принцип!программного управления}{Принцип программного
  управления.} Программа состоит из набора команд, выполняемых в
  определенной последовательности.
\item \Term{Принцип!жёсткости архитектуры}{Принцип жёсткости
  архитектуры.} Архитектура компьютера в ходе работы не изменяется.
\end{enumerate}

Отличие гарвардской архитектуры в том, что в ней память команд и
память данных разделены.

В соответствии с принципом двоичного кодирования программа для
компьютера дожна быть представлена в виде последовательнсти числовых
кодов. Но запись команд в таком виде неудобна для человека. Она не
очень наглядна и требует особой внимательности, заставляет отвлекаться
от решения непосредственно задачи.

Машинные команды слишком конкретны. Например, они требуют указания
адресов ячеек памяти, в которых хранятся данные. К тому же количество
команд хоть и может быть большим, но всё же сильно ограничено. Это
усложняет программирование, так как даже простые с точки зрения
человека операции приходится описывать несколькими командами. Поэтому
программы записывают сначала в человекочитаемом виде, а затем
преобразуют в машинные команды.

Как компромисс между требованиями аппаратного обеспечения и лёгкостью
описания решения задач, были созданы специальные языки для «общения»
человека и машины — языки программирования. С одной стороны они легки
для использования людьми, а с другой допускают перевод в машинные
команды.

\begin{defn}
  \Term{Язык!программирования}{Язык программирования} — это формальная
  система, предназначенная для описания решения задачи при помощи
  компьютера.
\end{defn}

Следует заметить, что программы на том или ином языке программирования
пишутся людьми для людей, так как компьютеру требуются для работы лишь
машинные коды. Об этом следует помнить, и писать программы так, чтобы
в них могли разобраться как сам программист, так и другие.

Для того, чтобы описать язык программирования, необходимо определить
его основные составляющие — синтаксис и семантику.

\begin{defn}
  \Term{Синтаксис}{Синтаксис} языка программирования — это набор
  формальных правил, определяющих какие последовательности символов
  являются допустимыми в этом языке без учёта вложенного в них смысла.
\end{defn}

Например, тот факт, что в математических выражениях в языке C\# для
каждой открывающей скобки должна присутствовать ппарная ей
закрывающая, — это требование синтаксиса.

Существуют формальные способы описания синтаксиса языков. Одним из
наиболее распространённых является так называемая \Term{Форма
  Бэкуса—Наура}{форма Бэкуса—Наура}. В ней синтаксис задаётся как
набор правил, описывающих отдельные понятия языка через другие понятия
или конкретные цепочки символов. Рассмотрим в качестве примера
синтаксис целых чисел:

\begin{verbatim}
число ::= знак цифра+|цифра+
цифра ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
знак  ::= '+'|'-'
\end{verbatim}

Обозначение «::=» используется для отделения определяемого понятия от
определения.

Знак «+» означает одно или более повторений. Таким образом, запись
«цифра+» соответствует одной или нескольким цифрам.

Символ «|» разделяет альтернативы. То есть, число — это либо
последовательность цифр со знаком, либо последовательность цифр без
знака.

В апострофах записываются уже не понятия, а конкретные символы из
текста программы.

Как видно из этого примера, описание синтаксиса позволяет лишь
определить, к какому понятию относится та или иная последовательность
символов.  При этом не указывается, как это понятие интерпретировать и
исполнять вычислительному устройству.

Иными словами, синтаксис позволяет лишь определить корректность какой-либо
записи. Например, выражения «12» и «+12» могут быть синтаксически
корректны, но эквивалентны они или нет, определить только с помощью
синтаксических правил невозможно. Для этого требуется информация о
заложенном в них смысле, то есть семантика.

\begin{defn}
\Term{Семантика}{Семантика} языка программирования — это формальное описание
значения понятий языка программирования.
\end{defn}

Существует три основныых подхода к описанию семантики:

\begin{itemize}
\item \Term{Семантика!операционная}{операционный} — конструкции языка
  описываются как перечень действий, выполняемых некоторым абстрактным
  компьютером;
\item \Term{Семантика!денотационная}{денотационный} (математический) —
  конструкции описываются с помощью различных математических понятий;
\item \Term{Семантика!деривационная}{деривационный} (аксиоматический)
  — подход, основанный на математической логике; действие конструкции
  описывается при помощи задания эффекта, который она оказывает на
  состояние программы.
\end{itemize}

Не каждый язык обладает достаточными выразительными возможностями для
описания произвольных вычислений. Например, рассмотренный выше язык
целых чисел описывает лишь сами числа, но не операции над ними. То
есть его практическая ценность минимальна.

Языки, при помощи которых принципиально возможно описать любой
возможный вычислительный процесс называются \Term{Язык!вычислительно
  универсальный}{вычислительно универсальными} или
\Term{Язык!Тьюринг-полный}{полными по Тьюрингу}. Полнота по Тьюрингу
желательна для языка, который используется на практике, но не
обязательна, если он узко специализирован. Также она гарантирует саму
возможность запрограммировать любое вычисление, но не простоту записи.
Поэтому разработчики стремятся сделать языки программирования как
можно более лаконичными и выразительными.

Важными составляющими любого языка являются также
\Term{Система типов}{система типов} и
\Term{Библиотека!стандартная}{стандартная библиотека}.

Типы — это средства определения различных разновидностей данных
(таких, как целые числа, векторы, матрицы и т.~д.), с которыми можно
работать при помощи конструкций языка. Очевидно, эта составляющая
играет чрезвычайно важную роль при программировании. Развитые языки
программирования содержат средства описания новых типов.

Стандартная библиотека — это набор типичных операций над данными,
которые, вообще говоря, не являются частью языка, но встречаются очень
часто, поэтому присутствуют в любой его реализации.

Первым языком программирования, широко применяемым на практике, был
FORTRAN (от англ. formula translator — переводчик формул),
разработанный в середине 50-х годов 20-го века. В настоящее время
существует несколько тысяч различных языков программирования. На
наиболее распространённые языки существуют международные
стандарты.

Главная причина появления такого количества языков, — необходимость в
специализированных инструментах, хорошо подходящих для решения
определённого класса задач.  Использование универсальных языков
программирования часто оказывается неоправданным, так как требует
написания большего количества программного кода. В то же время
специализированные языки обладают выразительными средствами,
позволяющими описать нужные действия при помощи всего нескольких
строк.

Спор о том, какой язык лучше, лишён смысла. Каждый язык хорош в своей
предметной области. На практике часто использут несколько зыкаов
одновременно.

К наиболее распространённым языкам относятся: Java, C, \CPP, C\#,
JavaScript, Perl, PHP, Visual Basic, Python, Ruby и другие.

\section{Классификация языков программирования}

Исторически языки программирования развивались в сторону увеличения
уровня абстракции используемых понятий. Первые компьютеры
программировались непосредственно в машинных кодах, поэтому
программисту приходилось оперировать лишь такими понятиями, как
«ячейка памяти», «адрес» и т.~д. Набор математических операций тоже
был ограничен.

В языке FORTRAN появилась возможность записывать математические
формулы в виде, близком к принятому в математике. Эти формулы не могли
быть непосредственно вычислены компьютером, поэтому требовался перевод
(трансляция) их в машинные команды. Причём одна формула
транслировалась сразу в несколько команд.

В дальнейшем языки программирования стали включать в себя возможности
работы со сложными структурами данных, такими как списки, очереди,
матрицы. При этом программисту уже не требовалось постоянно думать о
том, как эти структуры хранятся в памяти, и какие машинные команды их
обрабатывают.

Таким образом, первые языки были близки к машине, а новые и более
абстрактные близки к человеку. Подобное разделение позволяет ввести
следующую классификацию.

\begin{enumerate}
\item \Term{Язык!предметно-ориентированный}{Предметно-ориентированные
  языки} (DSL — domain specific languages) — языки программирования,
  ориентированные на решение узкого класса задач. Как правило,
  оперируют непосредственно понятиями предметной области, для которой
  разрабатывались. Например, в языке матричных вычислений Matlab
  матрица — одно из базовых понятий, включённых в сам язык. Примеры
  предметно-ориентированных языков: M-язык системы Matlab, языки
  пакетов Mathematica, MathCAD, Maple, язык статистических расчётов R,
  язык табличного процессора Excel и т.~д. Предметно-ориентированные
  языки очень распространены, так как часто проще разработать
  отдельный язык для решения задачи, чем пытаться решить её с помощью
  универсального языка.
\item \Term{Язык!высокого уровня}{Языки высокого уровня} — языки,
  предназначенные для решения широкого круга задач, и включающие
  конструкции высокой степени абстракции.  Иными словами, это
  универсальные языки близкие к человеку. Примеры: Java, \CPP, C\#,
  Pascal и т.~д.
\item \Term{Язык!низкого уровня}{Языки низкого уровня} — языки,
  предоставляющие минимальный уровень абстракции от машинных
  команд. Обычно они содержат средства для прямого доступа к памяти
  компьютера. С некоторой долей условности можно отнести к
  низкоуровневым, например, язык C и некоторые другие. Хоть он и
  достаточно универсален, многие конструкции в нём требуют для
  использования знание особенностей архитектуры компьютера.
\item \Term{Язык!ассемблера}{Язык ассемблера} (иногда просто
  ассемблер) — группа языков низкого уровня, не
  абстрагирующихся от машинных кодов. Практически каждая команда на
  языке ассемблера соответствует одной команде процессора.  Название
  этого класса происходит от термина \Term{Ассемблер}{ассемблер} (от англ.
  assembler — сборщик), соответствующего программе, переводящей
  команды в машинный код. У разных архитектур вычислительных устройств
  набор команд различается, поэтому для них требуются отдельные
  ассемблеры.
\item \Term{Код!машинный}{Машинный код} — набор числовых кодов,
  соответствующих действиям, которые может выполнять вычислительное
  устройство. Например, в процессорах архитектуры IA-32 команда
  завершения работы части программы кодируется числом
  ${C3}_{16}={195}_{10}$ (в языке ассемблера этому коду соответствует
  команда \Lst{ret}).
\end{enumerate}

Очевидно, чем выше уровень языка программирования, тем проще на нём
писать программы. С другой стороны, за высокий уровень абстракции
приходится платить производительностью, так как многие операции (такие
как управление памятью, например) приходится автоматизировать. Хоть
программа и получается компактной, из-за автоматизации некоторых
действий, количество реально исполняемых команд будет больше.

Рассмотрим примеры решения одной задачи на языках различного уровня.
Пусть требуется описать функцию вычисления n-го числа Фибоначчи:

\begin{eqnarray*}
F_{1} & = & 1,\\
F_{2} & = & 1,\\
F_{n} & = & F_{n-1}+F_{n-2}.
\end{eqnarray*}

Это числовая последовательность, в которой первые два элемента —
единицы, а каждый следующий элемент равен сумме двух предыдущих.

Предметно-ориентированный язык Mathematica предназначен для решения
математических задач, в том числе и связанных с числовыми
последовательностями. Поэтому в нём есть соответствующая встроенная
функция. Программа будет состоять всего из одной команды.

\begin{lstlisting}[language=Mathematica]
Fibonacci[n]
\end{lstlisting}

Однако эта команда приводит к выполнению процессором большого
количества машиных команд, необходимых для обеспечения работы самой
системы компьютерной алгебры Mathematica.

На языке высокого уровня Haskell программа описывается в виде, близком
к математическому определению.

\begin{lstlisting}[language=Haskell]
fib 1 = 1
fib 2 = 1
fib n = fib (n-1) + fib (n-2)
\end{lstlisting}

Необходимо заметить, что хоть такая запись программы и допустима, но
она не является самым эффективным решением поставленной задачи.
Рекурсия — определение функции через саму себя — в строке~3 приводит к
большому расходу памяти.

При программировании на низкоуровневом языке программирования C, часто
не удаётся так же кратко указать свойства вычисляемой функции.
Возможно использование рекурсии, но если для языка Haskell рекурсия
типична, то в C стараются её избегать. Поэтому в примере ниже описаны
конкретные действия вычислительной системы, приводящие к результату.

\begin{lstlisting}[language=C]
int fib(int n) {
	if (n <= 2)
		return 1;
	else {
		int a, b, c;
		a = 1;
		b = 1;
		n -= 2;
		do {
			c = a + b;
			a = b;
			b = c;
			n--;
		} while (n > 0);
	}
	return c;
}
\end{lstlisting}

Как видно из примера, количество команд в программе увеличилось. Это
объясняется тем, что каждая из них менее абстрактна и представима в
виде всего нескольких машинных команд. (В отличие от функции
\Lst{Fibonacci} в Mathematica, скрывающей за собой всё решение
поставленной задачи.) Упрощение команд приводит к увеличению их
количества.

На языке ассемблера для процессора архитектуры IA-32 функция принимает
вид (используется синтаксис фирмы Intel):

\begin{lstlisting}[language={[x86masm]Assembler}]
fib:
    mov edx, [esp+8]
    cmp edx, 2
    ja l1
    mov eax, 1
    ret
l1:
    push ebx
    mov ebx, 1
    mov ecx, 1
l2:
    lea eax, [ebx+ecx]
    cmp edx, 3
    jbe l3
    mov ebx, ecx
    mov ecx, eax
    dec edx
    jmp l2
l3:
    pop ebx
    ret
\end{lstlisting}

Каждая строка приведённой программы (за исключением строк,
заканчивающихся двоеточием, являющихся метками) соответствует
единственной машинной команде. Уровень абстракции минимален. Если в
программе на языке C ещё можно было использовать переменные, обращаясь
к ним по именам (\Lst{a}, \Lst{b} и так далее), то в данном случае
необходимо явно указывать, в каких ячейках памяти и каких регистрах
процессора размещать данные. Также необходимо знать и учитывать
архитектурные особенности процессора и операционной системы.

В то время как программа на C написанная для компьютера с другой
архитектурой процессора выглядит точно так же, программа на языке
ассемблера, скорее всего будет сильно отличаться из-за различий в
наборе команд и других особенностях.

Машинные команды для процессора архитектуры IA-32, решающие
поставленную задачу, представляют собой последовательность
чисел. Каждое число кодирует ту или иную команду процессора. Обычно
последовательность машинных команд записывается в шестнадцатиричной
системе счисления, так как запись в двоичной системе чересчур
громоздка. Для удобства последовательность разбивают на блоки по 8
цифр (то есть, по 4 байта):

\begin{lstlisting}
8B542408 83FA0277 06B80100 0000C353
BB010000 00B90100 00008D04 0B83FA03
760789CB 89C14AEB F15BC3
\end{lstlisting}

Как видно, сложность чтения по сравнению даже с программой на языке
ассемблера существенно возросла.

Существует и другой способ классификации — по способу описания
действий в программе.  В соответствии с ней языки программирования
классифицируются следующим образом:

\begin{enumerate}
\item \Term{Язык!императивный}{императивные} — программа представляет
  собой явное описание последовательности манипуляций над данными в
  памяти компьютера;
\item \Term{Язык!декларативный}{декларативные} — программа содержит
  описание цели и средств её достижения. Они в свою очередь делятся
  на:
  \begin{itemize}
  \item \Term{Язык!функциональный}{функциональные} — программа
    содержит описание функций, вызывающих друг друга;
  \item \Term{Язык!логический}{логические} — программа состоит из
    описания фактов, правил и цели.
  \end{itemize}
\end{enumerate}

Большинство языков программирования императивные, так как компьютер по
своей сути — это императивное устройство. Императивными являются,
например языки \CPP, C\#, Pascal, Visual Basic и другие. При
использовании этих языков необходимо явно указать последовательность
команд, приводящих к решению задачи.

Примером программы на декларативном (в частности, функциональном)
языке программирования является рассмотренная выше программа на языке
Haskell. В ней нет явно заданной последовательности действий, строки
программы можно менять местами. Но при вычислении конкретного значения
функции (например, \Lst{fib 10} — в Haskell не используются скобки при
перечислении аргументов функции), последовательность вычислений будет
восстановлена автоматически.

Другой пример функционального языка — это Excel. В нём каждую формулу
в ячейках можно считать функцией, которая зависит от значений в других
ячейках. Пользователь явно не задаёт последовательность вычисления,
Excel выполняет это самостоятельно.

Из-за отсутствия последовательности действий, многие типичные для
императивного языка операции заменяются на функциональные аналоги.
Например, вместо цикла приходится использовать рекурсию (определение
функции через саму себя, как в примере с числами Фибоначчи). Это
непривычно для человека, привыкшего программировать в императивном
стиле, и отчасти мешает широкому распространению функциональных
языков.

Функциональные языки получили в последнее время достаточно широкое
распространение, так как во многих случаях позволяют более лаконично
представить решение задачи. Примеры функциональных языков: Lisp,
Haskell, F\#, OCaml и т.~д.

Логические языки основаны на алгебре логики и, фактически, являются
системами логического вывода. Однако не каждую задачу легко
представить в виде набора фактов и правил, что ограничивает область
примнения логического программирования. Это неудобно, в частности, для
численных расчётов. Самым распространённым логическим языком
программирования являеся Prolog и его многочисленные
диалекты. Существуют и другие логические языки — Mercury, Oz и т.~д.

Сравнение рассмотренных классов приведено в таблице
\ref{tbl:PLclasses}.  В настоящее время многие языки сочетают в себе
элементы сразу нескольких подходов. Например, F\# являясь
функциональным содержит такие императивные конструкции, как циклы,
изменяемые переменные и т.~д.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|c|c|}
      \hline 
      & Преимущества & Недостатки\\
      \hline
      \hline
      \Vertical{Логический} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip Простое описание задач, связанных с принятием
        решений на основе логического вывода.

        --\enskip Упрощение разработки экспертных систем, работающих с
        фактами и правилами.
        \par\medskip
      \end{minipage} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip Узость класса эффективно решаемых задач.
        \par\medskip
      \end{minipage}\\
      \hline
      \Vertical{Функциональный} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip Отсутствие жёстко заданной последовательности
        действий упрощает автоматическое распараллеливание программ.
        
        --\enskip Математическая строгость языка позволяет применить
        более эффективные методы автоматической оптимизации программ.
        
        --\enskip Во многих случаях программы на функциональных языках
        более лаконичны и выразительны.
        \par\medskip
      \end{minipage} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip Сложности, связанные с описанием изменения состояния
        памяти.
        
        --\enskip Многие операции, такие как операции ввода-вывода,
        требуют задания последовательности действий, что вызывает
        дополнительные сложности.
        
        --\enskip Отсутствие понятия присваивания требует постоянного
        автоматического выделения и освобождения памяти.
        \par\medskip
      \end{minipage}\\
      \hline
      \Vertical{Императивный} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip Близость к архитектуре позволяет получить
        максимальное быстродействие.
        \par\medskip
      \end{minipage} &
      \begin{minipage}[t]{0.42\columnwidth}
        Создатель языка FORTRAN Дж.~Бэкус выделил следующие недостатки:
        
        --\enskip громоздкость, сложный синтаксис, слишком много
        понятий;
        
        --\enskip сильная связь с понятием «память»;
        
        --\enskip сложности в формализации понятия присваивания, что
        значительно усложняет анализ программ.
        \par\medskip
      \end{minipage}\\
      \hline 
    \end{tabular}
    \par
  \end{centering}
  
  \caption{Преимущества и недостатки различных классов языков программирования}
  \label{tbl:PLclasses}
\end{table}

Кроме принадлежности к императивным или декларативным языкам часто
также говорят о поддерживаемых языком парадигмах программирования.

\begin{defn}
  \Term{Парадигма программирования}{Парадигма программирования} — это
  система идей, понятий и методов, определяющих способ и стиль
  написания программы.
\end{defn}

Ниже перечислены наиболее распространённые парадигмы.

\begin{itemize}
\item \Term{Программирование!структурное}{Структурное
  программирование} (основоположник — Э.~Дейкстра). Программа
  представляется в виде иерархической структуры блоков команд.
\item
  \Term{Программирование!объектно-ориентированное}{объектно-ориентированное
    программирование} (А.~Кэй) — программа состоит из описания
  объектов, присутствующих в задаче, и взаимодействия между ними;
\item
  \Term{Программирование!событийно-ориентированное}{событийно-ориентированное
    программирование} — программа представляется в виде описания
  реакций на различные события.
\end{itemize}

Основным методом структурного программирования является
\Term{Декомпозиция}{декомпозиция} (разделение) задачи на
подзадачи. Каждая из подзадач программируется отдельно. Получившиеся в
результате блоки команд называют \Term{Подпрограмма}{подрограммами}.
Каждая подпрограмма может ссылаться на другие подпрограммы.

Использование подпрограмм позволяет уменьшить дублирование
программного кода. Если какая-то часть задачи повторяется, то её
описывают как подпрограмму и в дальнейшем используют ссылки на
неё. Это уменьшает объём программы и упрощает поиск ошибок.

Процесс разработки ведётся «сверху вниз». Вначале описывается решение
задачи со ссылками на ещё ненаписанные подпрограммы. Это увеличивает
уровень абстракции, уменьшает количество используемых команд и в
результате упрощает программирование. Затем, каждая подпрограмма, на
которую была ссылка программируется отдельно. Если подзадача всё ещё
сложна, то она также подвергается декомпозиции.

В объектно-ориентированном программировании в задаче выделяются
объекты — отдельные сущности, обладающие некоторым набором
свойств. Объекты, схожие по своей природе группируются в классы,
устанавливаются взаимоотношения между ними, а затем свойства и
поведение объектов каждого класса программируется.  Само решение
задачи представляется как взаимодействие объектов, отправляющих друг
другу сообщения.

Событийно-ориентированное программирование обычно используется, когда
задача заключается в обработке внешних запросов. Например, при
программировании графических интерфейсов. Вначале в задаче выделяют
возможные события (например, нажатие на кнопку), и для каждого события
пишется обработчик, то есть описывается реакция программы.

Часто языки поддерживают сразу неколько парадигм, то есть являются
\Term{Язык!мультипарадигменный}{мультипарадигменными}.

Когда говорят, что язык поддерживает ту или иную парадигму, имеют в
виду, что в языке присутствуют встроенные средства для реализации
подходов, её составляющих. Однако можно применять различные парадигмы
и в языках, их не поддерживающих. Например, библиотека GLib использует
объектно-ориентированный подход, хоть и написана на языке C, не
имеющем для этого встроенных средств.

\section{Алгоритмы и их сложность}

Одним из важнейших понятий в математике и компьютерных науках является
понятие алгоритма. Этим термином обычно называют метод, схему решения
какой-либо задачи.

\begin{defn}
  \Term{Алгоритм}{Алгоритм} — это точное предписание, определяющее
  вычислительный процесс, приходящий от варьируемых исходных данных к
  искомому результату за конечное число шагов.
\end{defn}

Из определения следуют свойства, которыми должен обладать любой
алгоритм:

\begin{itemize}
\item \Term{Дискретность}{дискретность} — алгоритм состоит из
  элементарных дискретных шагов, требующих конечного промежутка
  времени;
\item \Term{Детерминированность}{детерминированность} — в каждый
  момент времени известно, какой шаг будет выполняться следующим;
\item \Term{Понятность}{понятность} — алгоритм состояит только из
  шагов, однозначно интерпретируемых исполнителем — вычислительным
  устройством;
\item \Term{Конечность}{конечность} — для допустимого набора входных
  данных алгоритм должен завершаться за конечное число шагов;
\item \Term{Универсальность}{универсальность} — алгоритм должен быть
  применим к различным наборам входных данных;
\item \Term{Результативность}{результативность} — алгоритм должен
  приводить к искомому результату.
\end{itemize}

Отличие алгоритма от программы заключается в том, что алгоритм — это
последовательность шагов сама по себе, идея решения. А программа — это
запись шагов алгоритма на каком-то формальном языке. Так как любой
алгоритм, чтобы быть выполненным, должен быть записан в виде
программы, эти понятия часто отождествляют.

Алгоритм — это описание способа обработки данных. Очевидно, программа
для конкретного вычислительного устройства должна кроме алгоритма
также содержать описание обрабатываемых структур данных. Эта идея
нашла отражение в известной формуле, предложенной Н.~Виртом:
«алгоритмы + структуры данных = программы».

Важным этапом в разработке любого алгоритма является доказательство
его корректности, то есть правильности выдаваемого результата. Не
всегда это тривиально. Изучением свойств алгоритмов с математической
точки зрения занимается теория алгоритмов, а практическими аспектами
преобразования алгоритма в программу — технология программирования.

Для одной и той же задачи может существовать несколько корректных
алгоритмов. Например, отсортировать последовательность целых чисел по
возрастанию можно перемещая бо́льшие числа в конец последовательности,
а меньшие — в начало. А можно рассмотреть все возможные перестановки
заданной последовательности и выбрать среди них ту, которая уже
является отсортированной. Несмотря на то, что оба алгоритма приводят к
одному и тому же результату, их трудоёмкость значительно различается,
а значит, можно говорить и о различной эффективности этих
алгоритмов. Исследование эффективности можно формализовать, если
ввести понятие вычислительной сложности.

\begin{defn}
  \Term{Сложность вычислительная}{Вычислительная сложность} — это
  характеристика эффективности, выражающаяся в зависимости объема
  требуемых для работы ресурсов от размера входных данных.
\end{defn}

Под ресурсами понимают время (как правило) или память. Соответственно
рассматривают временну́ю сложность и пространственную (емкостную).
Временну́ю сложность часто называют просто сложностью алгоритма.

Сложность алгоритма — это некоторое математическое выражение,
выражающее зависимость времени или количества памяти от объёма
данных. Но записать это выражение без учёта быстродействия конкретного
вычислительного устройства невозможно.  Один и тот же алгоритм может
на различных компьютерах выполняться за различное время. Поэтому
исследуют не абсолютные значения времени, требуемого для получения
результата, а характер его увеличения при увеличении объема данных на
входе.

Для этого часто используют так называемые \Term{Ландау
  символы}{символы Ландау} (или \Term{O-нотация}{О-нотацию}). Это
специальные математичеcкие обозначения, позволяющие скрыть коэффициент
пропорциональности, соответствующий быстродействию, в выражениях для
сложности.

Чаще всего используют символ $O$ (читается как \Term{O большое}{«О
    большое»}).

\begin{defn}
  Говорят, что $f(n)=O(g(n)),$ если существуют такие константы
  $C\in\mathbb{R}$ и $n_{0}\in\mathbb{N},$ что для любого $n>n_{0}$
  выполняется неравенство $|f(n)|\leqslant|Cg(n)|.$
\end{defn}

То есть, приведённое обозначение говорит о том, что $f$ асимтотически
ограничена сверху функцией $g$ с точностью до постоянного
множителя. Иными словами, символ $O$ «скрывает» константу и медленно
растущие слагаемые.

Существуют и другие обозначения подобного рода. $\Omega$ —
асимптотическое ограничение снизу, $\Theta$ — асимтотическое
ограничение сверху и снизу.

Например, если время работы алгоритма описыватся выажением $5N+2,$
где $N$ — объем входных данных, то говорят, что такой алгоритм
обладает сложностью $O(N)$. Здесь символ $O$ скрыл константу и член
меньшего порядка.

Аналогично, $2N^2+7N+5 = O(N^2)$ и $5N\log N + 9N + 4 = O(N\log N)$.

Зная зависимость объёма ресурсов от объёма входных данных, можно
оценить эффективность алгоритма. Линейная сложность, как правило,
лучше, чем, например, квадратическая.  Однако, на практике иногда
лучше применить алгоритм с квадратической сложностью, так как
константа у алгоритма с линейной сложностью, скрывающаяся за символом
$O$, может оказаться значительно больше для всех $N,$ имеющих смысл на
практике.

Подобная ситуация возникла например в задаче перемножения матриц. Хоть
и известны алгоритмы быстрого перемножения матриц (например, алгоритм
Копперсмита~— Винограда, имеющий сложность $O(N^{2{,}3727})$, где $N$
— количество строк и столбцов матрицы), на практике часто пользуются
алгоритмом, основанным на определении произведения матриц, так как для
малых $N$ он эффективнее.

Поиск алгоритмов с минимальной возможной сложностью для конкретных
задач — одна из важнейших проблем современной теории алгоритмов. Эта
область науки активно развивается, но в ней до сих пор есть нерешённые
вопросы.

Часто встречающиеся сложности в порядке уменьшения эффективности и
примеры алгоритмов для каждой из них:

\begin{itemize}
\item константная ($O(1)$) — время работы не зависит от задачи —
  например, получение результата, который уже был предварительно
  посчитан и сохранён ранее;
\item логарифмическая ($O(\log N)$, основание логарифма не важно, так
  как все логарифмические функции растут пропорционально) — поиск
  фамилии в телефонной книге методом деления пополам ($N$ — количество
  абонентов);
\item линейная ($O(N)$) — суммирование последовательности чисел ($N$ —
  количество слагаемых);
\item линейно-логарифмическая ($O(N\log N)$) — сортировка
  последовательности чисел методом Хоара ($N$ — количество сортируемых
  элементов);
\item квадратическая ($O(N^{2})$) — так называемая сортировка вставками;
\item кубическая ($O(N^{3})$) — перемножение матриц размера $N\times
  N$ в соответствии с определением матричного умножения;
\item экспоненциальная ($O(2^{N})$) — алгоритм поиска решения при
  помощи полного перебора.
\end{itemize}

Сравнение времени работы алгоритмов с различной сложностью приведено в
таблице \ref{tbl:complexity}. Все алгоритмы предполагаются одинаково
быстрыми при $N=10$.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|c|c|c|c|}
      \hline 
      Сложность & $N=10$ & $N=100$ & $N=1000$ & $N=10000$\\
      \hline 
      \hline 
      $O(1)$       & $1$~c & $1$~c                   & $1$~c                    & $1$~c\\
      \hline 
      $O(\log n)$  & $1$~c & $2$~c                   & $3$~c                    & $4$~c\\
      \hline 
      $O(n)$       & $1$~c & $10$~c                  & $1{,}7$~мин.             & $16{,}7$~мин.\\
      \hline 
      $O(n\log n)$ & $1$~c & $20$~c                  & $5$~мин.                 & $1{,}1$~ч.\\
      \hline 
      $O(n^{2})$   & $1$~c & $1{,}7$~мин.            & $2{,}8$~ч.               & $11{,}6$~сут.\\
      \hline 
      $O(n^{3})$   & $1$~c & $16{,}7$~мин.           & $11{,}6$~сут.            & $31{,}7$~года\\
      \hline 
      $O(2^{n})$   & $1$~c & $3{,}9\cdot10^{19}$~лет & $3{,}3\cdot10^{290}$~лет & $6{,}2\cdot10^{2999}$~лет\\
      \hline 
    \end{tabular}
    \par
  \end{centering}
    
  \caption{Оценка времени работы алгоритмов различной сложности}
  \label{tbl:complexity}
\end{table}

Как видно, выбор достаточно эффективного алгоритма играет чрезвычайно
важную роль. Например, для задачи сортировки большого массива, замена
алгоритма сортировки вставками на алгоритм сортировки Хоара может
позволить получить результат за намного меньшее время.

С другой стороны не следует жертвовать сложностью. Если быстродействия
используемого алгоритма достаточно, то тратить время на его замену
было бы нерационально.
