\chapter{Трансляция и выполнение программ}

\section{Трансляция и интерпретация}

Как было показано в предыдущей теме, решение одной и той же задачи
может быть записано на различных языках программирования. Так как
языки программирования — это формальные системы, то задача «перевода»
программы с одного языка программирования на другой также поддаётся
формализации. Это позволяет создавать автоматические системы,
генерирующие текст программы на одном языке по тексту на другом
языке. Такие программы называются \Term{Транслятор}{трансляторами}, а
сам процесс — трансляцией.

\begin{defn}
  \Term{Трансляция}{Трансляция} — это преобразование программы с
  одного языка программирования в семантически эквивалентный текст на
  другом языке.
\end{defn}

Как правило, программы пишут для выполнения их на компьютере. Поэтому
особый интерес представляет преобразование текста программы в машинный
код — компиляция.

\begin{defn}
  \Term{Компиляция}{Компиляция} — трансляция программы в машинные
  коды.
\end{defn}

Программа, осуществляющая компиляцию называется
\Term{Компилятор}{компилятором}.  Для каждой пары «язык
  программирования — процессор» требуется отдельный компилятор, так
как процессоры различной архитектуры могут иметь различные наборы
команд.

Существуют компиляторы, способные генерировать машинный код для
процессоров сразу нескольких архитектур. Они называются
\Term{Кросс-компилятор}{кросс-компиляторами}.  Они могут
использоваться, например, при компиляции программ для
микроконтроллеров.  Это связано с тем, что запускать компилятор на
самом микроконтроллере нецелесообразно, а часто и вовсе невозможно
из-за ограниченности ресурсов последнего.

Форматы исполняемых файлов, в которых хранится машинный код,
различаются в различных операционных системах. Исполняемые файлы в
формате ELF, используемом в Linux, невозможно выполнить штатными
средствами в операционной системе Windows даже если аппаратное
обеспечение при этом одинаково. К тому же, операционные системы
предоставляют выполняемым программам различный набор системных
вызовов. Поэтому говорят, о компиляции не для конкретной архитектуры
процессора, а для конкретной
\Term{Платформа!программно-аппаратная}{программно-аппаратной
  платформы}. Под ней понимают совокупность аппаратного обеспечения и
операционной системы.

В настоящее время существует большое количество платформ, поэтому
становится важной проблема переносимости.

\begin{defn}
  \Term{Переносимость!программно-аппаратная}{Программно-аппаратная
    переносимость} — возможность запуска программы на различных
  платформах.
\end{defn}

Компиляторы новых языков программирования часто пишутся на этих же
языках. Сначала на каком-то другом языке реализуется компилятор
минимального подмножества нового языка. Затем на этом подмножестве к
компилятору дописывается поддержка остальных возможностей языка, пока
он не сможет сам скомпилировать себя. Этот процесс называется
\Term{Раскрутка компилятора}{раскруткой компилятора}. В нём компилятор
выступает и как обработчик исходного текста, и как результат
компиляции.

Кроме компиляции существует и другой подход к получению результата
работы программы: преобразование в машинный код не производится, а
каждая команда анализируется и тут же исполняется.

\begin{defn}
  \Term{Интерпретация}{Интерпретация} — это процесс покомандного
  анализа и исполнения текста программы.
\end{defn}

Не следует смешивать понятия компиляции и интерпретации, так как первое
— это преобразование программы, а второе — выполнение. Однако очевидно,
оба подхода должны приводить к одному и тому же результату для одной
и той же программы.

Для интерпретации необходимо приложение, производящее анализ и
выполнение команд. Оно называется
\Term{Интерпретатор}{интерпретатором}. Если для некоторого языка
программирования существует интерпретатор, то для него можно написать
компилятор. Верно и обратное. Однако, многие языки программирования
традиционно являются интерпретируемыми или компилируемыми.

Например, к традиционно компилируемым языкам относятся C, \CPP,
Fortran и так далее. Интерпретаторы для них не получили широкого
распространения.  Традиционно интерпретируемыми языками являются
Python, Perl, PHP и другие.

Оба рассмотренных подхода обладают как преимуществами, так и
недостатками.

К основным преимуществам компиляции относят независимость результатов
компиляции от наличия компилятора во время выполнения и, как правило,
более высокую скорость исполнения результата компиляции.

Первое объясняется тем, что результат компиляции — это машинный код,
который можно исполнять непосредственно. В компиляторе возникает
необходимость однократно — лишь в момент компиляции.

Второе преимущество объясняется наличием в полученном машинном коде
только команд, решающих поставленную задачу. Кроме того из-за
однократности компиляции можно позволить потратить больше времени на
автоматическую оптимизацию программы — исключение лишних действий,
применение более эффективных конструкций и так далее. Лидерами по
быстродействию результирующего машинного кода считаются компиляторы
языков C и Fortran. Компиляторы последнего особенно эффективны при
программировании задач, связанных с обработкой больших числовых
массивов.

Одним из главных преимуществ интерпретации (и часто решающим) является
высокая переносимость между программно-аппаратными платформами. В
самом деле, при появлении нового процессора или новой операционной
системы нет необходимости в перекомпиляции уже существующих программ.
Достаточно написать под новую платформу интерпретатор.

Так, например, одна и та же программа на языке Python может работать
на компьютере как под управлением операционной системы Windows, так и
под управлением Linux. Сама программа представляет собой текст,
сохранённый в файл. Чтобы выполнить её необходимо запустить
интерпретатор и указать, какой файл выполнять. Обычно запуск
интерпретатора выполняется автоматически.

Для того, чтобы объединить преимущества обоих подходов, в последнее
время часто используется гибридная схема. В соответствии с ней,
программа сначала компилируется в некоторый промежуточный код, который
затем интерпретируется. Схема получения результата работы программы в
этом случае приведена на рис.~\ref{fig:pcode}.

\begin{figure}
  \begin{centering}
    \tikzstyle{nd} = [
      rectangle,
      rounded corners,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \tikzstyle{nd0} = [
      rectangle,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \begin{tikzpicture}[
	thick,
	node distance=2cm,
	text height=1.2ex,
	text depth=.1ex,
	auto]
      \node[nd]                    (source) {Исходный текст};
      \node[nd,  below of=source]  (pcode)  {Промежуточный код};
      \node[nd0, below of=pcode]   (result) {Результат};
      
      \path[->] (source) edge node {Компиляция}     (pcode);
      \path[->] (pcode)  edge node {Интерпретация}  (result);
    \end{tikzpicture}
    \par
  \end{centering}
  
  \caption{Компиляция в промежуточный код\label{fig:pcode}}
\end{figure}

\begin{defn}
  \Term{Код!промежуточный}{Промежуточный код} (или
  \Term{Байт-код}{байт-код}) — промежуточное представление программы
  на машинно-независимом языке низкого уровня.
\end{defn}

Промежуточный код формально является программой на некотором
\Term{Язык!промежуточный}{промежуточном языке}. Для упрощения
интерпретатора и повышения скорости его работы в большинстве случаев
промежуточный язык делается как можно проще.  Фактически,
разрабатывается машинный язык для некоторого абстрактного
компьютера. Поэтому интерпретатор промежуточного кода называют
\Term{Машина!виртуальная}{виртуальной машиной}.

Преимущество использования промежуточного кода заключается в том, что
часть действий (анализ исходного текста, обнаружение ошибок,
оптимизация) выполняется заранее компилятором, что увеличивает
скорость работы интерпретатора. При этом сохраняется
программно-аппаратная переносимость, так как промежуточный код, хоть и
является близким к машинным командам, не привязан к какой-то
конкретной архитектуре.

Также следует отметить возможность введения в промежуточный язык более
высокоуровневых конструкций по сравнению с машинными командами.

Особенно широко компиляция в промежуточный код стала применяться после
распространения мобильных платформ, так как в этом случае особенно
остро стоит проблема переносимости.

Примерами программных систем, основанных на использовании
промежуточного кода, являются .NET и Java. В частности, .NET — это
программная платформа, разработанная компанией Microsoft, в основе
которой лежит виртуальная машина CLR (от англ. Common Language Runtime
— общеязыковая исполняющая среда), способная выполнять промежуточный
код на языке CIL (от англ. Common Intermediate Language — общий
промежуточный язык).

Также платформа .NET включает в себя обширную стандартную библиотеку
классов (FCL — Framework Class Library, библиотека классов платформы)
и компиляторы с высокоуровневых языков (например, C\#) в CIL.

Платформа .NET стандартизирована международными организациями, а
именно ISO и ECMA. Наличие стандарта на платформу позволило создать её
независимые реализации — например, Mono и Portable.NET. Благодаря им
промежуточный код можно исполнять не только в операционной системе
Windows, но и в других операционных системах и мобильных платформах.

Java — это тоже платформа, сочетающая в себе виртуальную машину и
компилятор с одноимённого языка. Существуют различные реализации
виртуальной машины Java и компиляторы с других языков (Jython, Scala и
так далее) в её промежуточный код. Благодаря использованию
промежуточного кода, платформа Java используется в самых разных
мобильных и встраиваемых устройствах с различным аппаратным
обеспечением.

При использовании рассмотренной схемы с интерпретацией промежуточного
кода, по-прежнему остаётся актуальной проблема быстродействия.
По-прежнему приходится выполнять интерпретацию, пусть и более простого
промежуточного кода. Решением проблем является так называемая
динамическая компиляция.

\begin{defn}
  \Term{Компиляция!динамическая}{Динамическая компиляция} или
  \Term{JIT-компиляция}{JIT-компиляция} (от англ. just-in-time — точно
  в срок) — получение машинного кода во время выполнения программы.
\end{defn}

\begin{figure}
  \begin{centering}
    \tikzstyle{nd} = [
      rectangle,
      rounded corners,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \tikzstyle{nd0} = [
      rectangle,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \begin{tikzpicture}[
	thick,
	node distance=2cm,
	text height=1.2ex,
	text depth=.1ex,
	auto]
      \node[nd]                    (source) {Исходный текст};
      \node[nd,  below of=source]  (pcode)  {Промежуточный код};
      \node[nd,  below of=pcode]   (mcode)  {Машинный код};
      \node[nd0, below of=mcode]   (result) {Результат};
      
      \path[->] (source) edge node {Компиляция}     (pcode);
      \path[->] (pcode)  edge node {Динамическая компиляция}  (mcode);
      \path[->] (mcode) edge node {Выполнение}     (result);
    \end{tikzpicture}
    \par
  \end{centering}

  \caption{Компиляция в промежуточный код\label{fig:jit}}
\end{figure}

Схема получения результата приведена на рис.~\ref{fig:jit}. Компиляция
в промежуточный код с необходимыми оптимизациями производится
заранее. Машинный код под конкретную платформу генерируется, когда
программа уже выполняется. При этом он обычно не сохраняется в виде
файла, а сразу помещается в оперативную память.

Прирост быстродействия обеспечивается тем, что машинный код не требует
интерпретации, а выполняется непосредственно компьютером. К тому же
компиляция промежуточного кода намного менее затратная операция по
сравнения с компиляцией программ на высокоуровневых языках.

Подобный подход применяется, например, в платформе .NET. Для повышения
производительности, виртуальная машина CLR выполняет динамическую
компиляцию. Также этот подход хорошо зарекомендовал себя в
интерпретируемых языках программирования.

Например, V8 — интерпретатор языка JavaScript, применяемого в
веб-браузерах, — показывает чрезвычайно высокую производительность
именно благодаря использованию динамической компиляции. Для повышения
быстродействия разработчики отказались от использования промежуточного
кода, так что, фактически, отличие от обычной компиляции заключается
только в моменте преобразования кода.

Другое преимущество использования подобной двухэтапной компиляции
заключается в абстрагировании от конкретного аппаратного
обеспечения. Программисту достаточно изучить возможности виртуальной
машины, чтобы писать программы для всех платформ, на которых она
работает.

Использование динамической компиляции приводит к интересным эффектам.
Например, код, выполняемый интерпретатором PyPy языка Python,
выполняется быстрее, чем код выполняемый CPython. При этом PyPy сам
написан на Python и его код также выполняется CPython. Этот
неожиданный результат объясняется тем, что PyPy использует
динамическую компиляцию, а CPython — нет.

Кроме динамической компиляции распространена и предварительная
компиляция — \Term{AOT-компиляция}{AOT-компиляция} (от англ. ahead of
time — заранее). В этом случае компиляция промежуточного кода в
машинный происходит непосредственно перед запуском программы. Подобной
возможностью обладает, например, виртуальная машина Mono.

Написание компиляторов и интерпретаторов — достаточно сложная задача,
поддающаяся, однако, автоматизации. Для этого используют так
называемые \Term{Компилятор!компиляторов}{компиляторы компиляторов} —
приложения, генерирующие код компилятора или его части по описанию
языка. Примерами компиляторов компиляторов являются ANTLR, GNU~Bison и
другие. Они чрезвычайно полезны при разработке собственных
предметно-ориентированных языков.

При разработке программ используются также
\Term{Анализатор!статический}{статические анализаторы} — программы
проводящие глубокий анализ исходного текста программы на предмет
потенциальных ошибок.

Следует также упомянуть другие полезные инструменты, используемые при
разработке программного обеспечения — \Term{Отладчик}{отладчик} и
\Term{Профилировщик}{профилировщик}. Первый позволяет выполнять
программу по шагам в поисках ошибки, а второй анализирует время
выполнения различных её частей.

\section{Этапы трансляции программы}

Несмотря на то, что процесс трансляции сильно зависит от языка
программирования, в нём можно выделить несколько общих этапов.

Большие программы обычно разбивают на несколько файлов, а проектом
называют все файлы, относящиеся к конкретной программе.  Иногда
проекты объединяют в более крупную структурную единицу —
\Term{Решение}{решение}.  Решение соответствует приложению целиком, а
проекты — отдельным исполняемым файлам, составляющим его.

Рассмотрим процесс трансляции на примере компиляции
\Term{Проект}{проекта} на языке \CPP. Обычно он состоит из файлов с
расширениями «.cpp» и «.h».  И те, и другие содержат исходный текст
программы на языке \CPP, но компилируются только файлы «.cpp». Файлы
«.h» (так называемые заголовочные файлы) используются только для
непосредственной подстановки в другие файлы. Это особенность языка
\CPP\ и его предшественника — языка C.  В языке C\#, например,
заголовочные файлы не используются и исходный текст хранится только в
файлах с расширением «.cs».

Также в проект могут быть включены и другие файлы. Например, с
описанием графического интерфейса программы, изображениями,
используемыми в ней, и т.~д.

На рис.~\ref{fig:compilation} приведена диаграмма, описывающая процесс
компиляции.

\begin{figure}
  \begin{centering}
    \tikzstyle{nd} = [
      rectangle,
      rounded corners,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \tikzstyle{nd0} = [
      rectangle,
      thick,
      minimum size=1cm,
      draw=black!100]
    
    \tikzstyle{line} = [draw, -latex']
    
    \begin{tikzpicture}[
	thick,
	node distance=1.9cm,
	text height=1.2ex,
	text depth=.1ex,
	auto]
      \node[nd]                    (cpp1) {.cpp};
      \node[nd, right of=cpp1]     (cpp2) {.cpp};
      \node[nd, right of=cpp2]     (cpp3) {.cpp};
      \node[nd, right of=cpp3]     (h1)   {.h};
      
      \node[nd0, below of=cpp1]    (tu1) {ЕТ 1};
      \node[nd0, below of=cpp2]    (tu2) {ЕТ 2};
      \node[nd0, below of=cpp3]    (tu3) {ЕТ 3};
      
      \node[nd, below of=tu1]      (obj1) {.obj};
      \node[nd, below of=tu2]      (obj2) {.obj};
      \node[nd, below of=tu3]      (obj3) {.obj};
      \node[nd, right of=obj3]     (lib)  {.lib};
      \node[nd, right of=lib]      (dll)  {.dll};
      
      \node[nd, below of=obj2]     (exe) {.exe};
      
      \path[line] (cpp1) edge (tu1);
      \path[line] (cpp2) edge (tu2);
      \path[line] (cpp3) edge (tu3);
      
      \path[line] (h1) -- ++(0,-1) -- ++(-1, 0) --  (tu3);
      \path[line] (h1) -- ++(0,-1) -- ++(-3, 0) --  (tu2);
      \path[line] (h1) -- ++(0,-1) -- ++(-5, 0) --  (tu1);
      
      \path[line] (tu1)  edge (obj1);
      \path[line] (tu2)  edge (obj2);
      \path[line] (tu3)  edge (obj3);
      
      \path[line] (obj1) edge (exe);
      \path[line] (obj2) edge (exe);
      \path[line] (obj3) edge (exe);
      
      \path[line, dashed] (dll) |- (exe);
      \path[line]         (lib) -- ++(0,-1) -- (exe);
      
      \node [anchor=west] (pp) at +(-3.5, -1) {1. Препроцессинг};
      \node [anchor=west] (pp) at +(-3.5, -3) {2. Компиляция};
      \node [anchor=west] (pp) at +(-3.5, -5) {3. Связывание};
    \end{tikzpicture}
    \par
  \end{centering}
  
  \caption{Пример компиляции проекта на языке \CPP\label{fig:compilation}}
\end{figure}

Как видно из рисунка, процесс состоит из трёх этапов.

\begin{enumerate}
\item Предварительная обработка
\item Компиляция
\item Связывание
\end{enumerate}

Первые два этапа каждый файл проекта на \CPP проходит независимо от
остальных.  Такой подход называется
\Term{Компиляция!раздельная}{раздельной компиляцией}. Он удобен тем,
что при изменении только одного файла, нет необходимости обрабатывать
остальные.  Компиляторы языка C\# достаточно быстрые, поэтому в них
раздельная компиляция, вообще говоря, не применяется. Однако
промежуточные результаты компиляции могут сохраняться на диск.

Этап \Term{Обработка!предварительная}{предварительной обработки} (или
\Term{Препроцессинг}{препросессинга}, от англ. preprocessing)
предназначен для преобразования исходного текста программы без какого
либо его анализа. Часть компилятора, выполняющая предварительную
обработку, называется препроцессор.

Предварительная обработка может быть удобна, например, для исключения
какой-либо части текста программы или замены некоторого символа
другим.  Обработка выполняется в соответствии со специальными,
командами, называемыми \Term{Директивы препроцессора}{директивами
  препроцессора}. Программы на языке C часто содержат большое
количество директив, но в языке \CPP\ их количество меньше из-за наличия
других средств для получения того же результата. Тем не менее,
директивы используются и в программах на \CPP\ (в особенности, директива
\Lst{\#include}, включающая содержимое одного файла в другой).

Злоупотреблять директивами не стоит. Так как они не анализируются
компилятором, то могут стать причиной труднонаходимых ошибок.

В C\# также применяются аналоги директив предварительной обработки
языков C и \CPP. Но следует заметить, что отдельный этап
предварительной обработки в C\# отсутствует, а директивы выполняются
непосредственно компилятором.

В языке C\# допускаются следующие директивы:

\begin{itemize}
\item \Lst{\#define}, \Lst{\#undef} — соотвественно определяет или
  отменяет определение символа — некоторого параметра, используемого в
  других директивах;
\item \Lst{\#if}, \Lst{\#elif}, \Lst{\#else}, \Lst{\#endif} —
  позволяют исключить участок программного кода в зависимости от того,
  определён ли некоторый символ;
\item \Lst{\#line} — используется для определения номера строки с
  ошибкой или предупреждением;
\item \Lst{\#error}, \Lst{\#warning} — позволяет сгенерировать
  соответственно ошибку или предупреждение на этапе компиляции;
\item \Lst{\#region}, \Lst{\#endregion} — позволяет пометить участок
  программы для удобства чтения;
\item \Lst{\#pragma} — предназначена для передачи параметров
  компилятору.
\end{itemize}

Например, в приведённой ниже программе строка 3 останется в файле, так
как символ \Lst{DEBUG} определён в строке 1 и директива
\Lst{\#if} включает текст в единицу трансляции. Если же удалить
строку 1, то строка 3 в дальнейшем будет проигнорирована компилятором,
так как в этом случае символ \Lst{DEBUG} будет уже не определён.

\lstset{morekeywords={define, endif}}
\begin{lstlisting}
#define DEBUG
#if DEBUG
Console.WriteLine("x = {0}", x);
#endif
\end{lstlisting}
\lstset{deletekeywords={define,endif}}

Рассмотренный в примере приём может полезен при отладке программы.

После того, как все директивы препроцессора выполнены, они удаляются
из исходного текста программы. Получившиеся после предварительной
обработки файлы называются \Term{Единица трансляции}{единицами
  трансляции}, и именно они подаются на вход компилятору.

Следующий этап — этап \Term{Компиляция}{компиляции}, на котором
единицы трансляции преобразуются в машинные команды. Он достаточно
сложен, поэтому в нём выделяют несколько подэтапов:

\begin{itemize}
\item лексический анализ,
\item синтаксический анализ,
\item семантический анализ,
\item оптимизация и
\item генерация кода.
\end{itemize}

\Term{Анализ!лексический}{Лексический анализ} — это выделение в
исходном тексте программы неделимых логических единиц, составляющих
программу. Такие единицы называют \Term{Лексема}{лексемами}. Ими
являются, например, ключевые слова, имена переменных, символы операций
и т.~д.

Например, фрагмент программы
\begin{lstlisting}
  while (count < 10) {count++;}
\end{lstlisting}
разбивается на лексемы следующим образом:

\Lst{\begin{center}
  \fbox{\strut while}
  \fbox{\strut (}
  \fbox{\strut count}
  \fbox{\strut <}
  \fbox{\strut 10}
  \fbox{\strut )}
  \fbox{\strut \{}
  \fbox{\strut count}
  \fbox{\strut ++}
  \fbox{\strut ;}
  \fbox{\strut \}}
\end{center}}

Каждая лексема в соответствии со своим назначением может быть
помечена соответствующим образом.

После выделения лексем компилятор производит поиск синтаксических
конструкций, образуемых ими — выполняет
\Term{Анализ!синтаксический}{синтаксический анализ}. Одним из часто
используемых способов представления результата синтаксического разбора
потока лексем являются так называемые \Term{Дерево!абстрактное
  синтаксическое}{абстрактные синтаксические деревья}
(\Term{AST}{AST}).

\Term{Дерево}{Деревом} называется иерархическая конструкция, состоящая
из точек (узлов), соединённых отрезками (ветвями). Особенностью
деревьев является отсутствие циклов, то есть между двумя узлами
существует только один путь по ветвям. Узлы, не имеющие связей с
узлами на более низком уровне, называются листьями.

Существуют разные способы представления программы в виде дерева. В
одном из них в листьях располагаются \Term{Операнд}{операнды} (то, над
чем производятся действия), а в остальных узлах —
\Term{Операция}{операции} (сами действия). Такое представление
позволяет однозначно описать программу. При этом оно отражает также
взаимосвязи между лексемами, поэтому деревья — чрезвычайно удобный
способ втнутреннего представления программ в компиляторе.

Пример абстрактного синтаксического дерева для выражения
\[
12(2x+3)
\]
приведён на рис.~\ref{fig:ast}.

\begin{figure}
  \begin{centering}
    \tikzstyle{line} = [draw, -latex']
    
    \begin{tikzpicture}[
	thick,
	node distance=1cm,
	text height=1.2ex,
	text depth=.1ex,
	auto]
      \node                    (oTimes1) {$\times$};
      \node[below of=oTimes1]  (empty1)  {};
      \node[left  of=empty1]   (n12)     {$12$};
      \node[right of=empty1]   (oSum)    {$+$};
      \node[below of=oSum]     (empty2)  {};
      \node[left  of=empty2]   (oTimes2) {$\times$};
      \node[right of=empty2]   (n3)      {$3$};
      \node[below of=oTimes2]  (empty3)  {};
      \node[left  of=empty3]   (n2)      {$2$};
      \node[right of=empty3]   (x)       {$x$};
      
      \path[line] (oTimes1) edge (n12);
      \path[line] (oTimes1) edge (oSum);
      \path[line] (oSum)    edge (oTimes2);
      \path[line] (oSum)    edge (n3);
      \path[line] (oTimes2) edge (n2);
      \path[line] (oTimes2) edge (x);
    \end{tikzpicture}
    \par
  \end{centering}

  \caption{Пример абстрактного синтаксического дерева\label{fig:ast}}
\end{figure}

Абстрактные синтакические деревья удобны тем, что, представляя текст
программы, позволяют судить о входящих в него конструкциях, порядке их
выполнения и так далее.

В ходе \Term{Анализ!семантический}{семантического анализа} для
абстрактного синтаксического дерева определяются действия, требуемые
для выполнения закодированной в нём программы.

Действия обычно записываются не в виде машинных команд, а в виде
последовательности так называемых \Term{Триада}{триад} (троек) или
\Term{Тетрада}{тетрад} (четвёрок). Триада кодирует код операции и
адреса двух аргументов. В тетраде дополнительно указывается адрес
ячейки памяти, в которую будет помещён результат.

Зная действия, к которым сводится программа, и их свойства можно
провести \Term{Оптимизация}{оптимизацию}. Это процесс преобразования
программы, направленный на уменьшение объёма результирующего кода или
уменьшение времени его работы.

Оптимизация заключается обычно в исключении операций, результат
которых не используется в дальнейшем, в упрощении и предварительном
вычислении арифметических выражений и т.~д.

Существует множество методов оптимизации программ, например:
\begin{itemize}
\item удаление кода, который гарантированно не выполнится;
\item развёртка циклов в линейную последовательность команд или
  свёртка повторяющихся команд в цикл;
\item вынесение общих подвыражений за пределы цикла;
\item объединение операций ветвления со схожими условиями, а также
  разделение ветвлений;
\item векторизация — применение команд процессора, позволяющих
  обрабатывать несколько величин одновременно и другие.
\end{itemize}

Не для всех видов оптимизации строго доказано, что они не изменяют
семантику программы. Поэтому в компиляторах, как правило,
предусмотрена возможность отключения той или иной оптимизации.

Современные компиляторы обладают достаточно мощными средствами для
оптимизации программ. Значительную их часть составляют именно
алгоритмы оптимизации программы. Часто их результаты оказываются
лучше, чем код, оптимизированный вручную человеком. Это одна из причин
придеживаться при программировании принципа не оптимизировать
программу, если в этом нет нужды.

Последним подэтапом компиляции является \Term{Генерация
  кода}{генерация кода}, когда непосредственно определяются
последовательности машинных команд или команд промежуточного кода,
требуемые для выполнения программы.

При раздельной компиляции машинные команды, соответствующие каждой
единице трансляции, помещаются в так называемые
\Term{Файлы!объектные}{объектные файлы}, которые обычно имеют
расширение «.obj» (Windows) или «.o» (Linux).

Объектные файлы содержат только часть программы, и в них могут
находиться вызовы подпрограмм, определённых в других единицах
трансляции, а значит их нельзя выполнить непосредственно.  Кроме того,
в объектных файлах могут содержаться ссылки на стандартные
подпрограммы, код которых расположен в так называемых библиотеках.
Поэтому для получения исполняемого файла необходимо объединить
объектные файлы и связать их с библиотечным кодом. Это происходит на
этапе \Term{Связывание}{связывания}.

Результат всех трёх этапов трансляции, как правило, — это исполняемый
файл, который можно запустить на компьютере, или библиотека, хранящая
подпрограммы, которые можно использовать при разработке других
программ.

\section{Исполняемые файлы и библиотеки}

\begin{defn}
  \Term{Файл!исполняемый}{Исполняемый файл} — это файл, содержащий
  программу в виде, в котором она может быть исполнена компьютером.
\end{defn}

Исполнителем может быть как непосредственно процессор (если файл
содержит машинные команды) или виртуальная машина (если файл содержит
промежуточный код).

Исполняемые файлы в операционной системе Windows обычно имеют
расширение «.exe». Причём файлы с этим расширением могут содержать как
машинный код, так и команды виртуальной машины .NET. У исполняемых
файлов в операционной системе Linux расширений как правило нет.

Кроме машинного или промежуточного кода исполняемые файлы также обычно
содержат информацию о самой программе: номер версии, её значок и
дополнительные сведения. Поэтому исполняемые файлы не могут быть
просто запущены на другой программно-аппаратной платформе, если она не
поддерживает данный тип исполняемых файлов.

При разработке сложных компьютерных программ иногда приходится
использовать часто встречающиеся операции, такие как, например,
вычисление наибольшего общего делителя, вывод информации на экран,
работа с матрицами и так далее. Для того, чтобы избежать дублирования
программного кода, типичные действия оформляются в виде
\Term{Подпрограмма}{подпрограмм} — небольших участков программного
кода, предназначенных для выполнения тех или иных действий.
Подпрограммы группируются в так называемые библиотеки, которые в
дальнейшем можно использовать в других программах.

\begin{defn}
  \Term{Библиотека}{Библиотека} — это распространяемая независимо
  коллекция подпрограмм, используемых как части других программ.
\end{defn}

Библиотеки могут разрабатываться программистом для своих собственных
нужд. Часто использование библиотек оправдано даже если они
используются только в одном единственном проекте, так как они
позволяют, например, реализовать \Term{Принцип!модульности}{принцип
  модульности}. Модульность означает, что программа разбивается на
отдельные, как можно меньше связанные между собой части. Разработать и
отладить отдельную часть проще, чем программу целиком, что
положительно сказывается на процессе разработки. Сравнительно слабые
связи между модулями позволяют достаточно легко модифицировать
отдельные части программы.

Многие библиотеки достаточно широко известны. Например:
\begin{itemize}
\item Gtk+, Qt — библиотеки для создания графического
  пользовательского интерфейса;
\item OpenGL, DirectX — библиотеки для написания приложений,
  использующих двумерную и трёхмерную графику;
\item MKL, IMSL, LAPACK, GSL, NAG — библиотеки, содержащие
  подпрограммы для численных расчётов;
\item MathGL, PLplot — библиотеки для визуализации численных данных,
\item OpenSSL — библиотека для шифрования и безопасной передачи данных
  по сети и т.~д.
\end{itemize}

В настоящее время существует огромное количество свободно доступных
библиотек разного назначения. Например, в дистрибутиве Debian
операционной системы Linux их около 4 тысяч. Перед тем, как начать
разработку сложного программного продукта, сперва следует изучить
существующие библиотеки, чтобы выяснить, не помогут ли они упростить
написание программы.

Существует три основных способа организации библиотеки:
\begin{enumerate}
\item в виде исходного текста,
\item статически связываемая библиотека,
\item динамически связываемая библиотека.
\end{enumerate}

Каждый из способов имеет свои преимущества и недостатки. Сравнение
двух наиболее распространённых приведено в таблице \ref{tab:lib-vs-dll}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|c|c|}
      \hline 
      & Преимущества & Недостатки\\
      \hline 
      \hline 
      \Vertical{Статические} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip программа не требует дополнительных действий по
        подключению при выполнении.
        \par\medskip
      \end{minipage} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip необходимость перекомпиляции при обновлении
        библиотеки;
        
        --\enskip код библиотеки дублируется в каждом процессе,
        использующем ей.
        \par\medskip
      \end{minipage}\\
      \hline
      \Vertical{Динамические} &
      \begin{minipage}[t]{0.42\columnwidth}
        --\enskip возможность обновления библиотеки без перекомпиляции
        программы;
        
        --\enskip различные процессы могут совместно использовать один
        экземпляр загруженной в память библиотеки;
        
        --\enskip возможность подключать библиотеки на этапе
        выполнения.
        \par\medskip
      \end{minipage} & %
      \begin{minipage}[t]{0.42\columnwidth}%
        --\enskip при выполнении программы требуются действия по
        загрузке библиотеки в память;
        
        --\enskip проблема одновременного использования различных
        версий одной библиотеки.
        \par\medskip
      \end{minipage}\\
      \hline 
    \end{tabular}
    \par\end{centering}
    
    \caption{Сравнение статически и динамически связываемых
      библиотек\label{tab:lib-vs-dll}}
\end{table}

При распространении библиотеки в виде исходного текста, она
представляет собой обычные файлы с текстом программы на том или ином
языке программирования. Для того, чтобы использовать такую библиотеку,
необходимо просто включить её файлы в свой проект.

Преимуществом подобного подхода является предельная его простота.  Для
того, чтобы создать библиотеку не требуется выполнения никаких
дополнительных действий. Достаточно просто описать требуемые
подпрограммы на выбранном языке программирования. Кроме того,
программист может изучать исходный текст библиотеки для того, чтобы
более эффективно её использовать.

С другой стороны, возникают следующие проблемы. Несмотря на то, что
библиотека содержит код, которые не предполагается изменять, его всё
равно необходимо каждый раз компилировать вместе с кодом основного
проекта, что может значительно увеличить время трансляции. Если автор
библиотеки модифицирует её, то для того, чтобы воспользоваться
изменениями, необходимо будет перекомпилировать весь проект
целиком. Если у конечного пользователя не будет исходных текстов
проекта, то он не сможет обновить часть кода программы,
соответствующего тексту библиотеки.

Кроме того, если запустить на компьютере несколько процессов,
соответствующих программам, использующим некоторую библиотеку, то код
библиотеки будет продублирован в памяти, так как для каждого процесса
его код будет загружен в память полностью, несмотря на то, что у них
есть общая часть — использованная библиотека.

Указанные недостатки достаточно критичны, поэтому этот способ
организации библиотек используется сравнительно редко.

Проблемы связанные с компиляцией можно частично решить, используя
\Term{Библиотека!статически связываемая}{статически связываемые
  библиотеки}. Они представляют собой заранее скомпилированные
подпрограммы, поэтому отпадает необходимость в компиляции библиотеки
программистом, использующим её.

Статически связываемая библиотека представляет собой набор объектных
файлов, содержимое которых для удобства помещается в один файл-архив.
Такой файл обычно имеет расширение «.lib» (Windows) или «.a» (Linux).

На этапе связывания код использованных в программе библиотечных
подпрограмм непосредственно помещается в исполняемый файл. Фактически,
статически связываемая библиотека — это просто архив с заранее
скомпилированными исходными тестами подпрограмм. Таким образом, они не
решают проблему дублирования машинного кода в памяти, так как код,
хранящийся в исполняемом файле, загружается в память целиком.

Для решения этой проблемы используют \Term{Библиотека!динамически
  связываемая}{динамически связываемые библиотеки}.  Как и статически
связываемые, они представляют собой файлы с заранее скомпилированными
подпрограммами. Однако, код из них не копируется, а хранится в файле
библиотеки. В исполняемый файл вставляется лишь ссылка на подпрограмму
в соответствующем файле.

Файлы динамически связываемых библиотек обычно имеют расширение «.dll»
(Windows) или «.so» (Linux).

Преимуществом библиотек является то, что они загружаются в память
однократно, даже если они используются несколькими процессами.

Другой особенностью динамически связываемых библиотек является то, что
их загрузкой в память может управлять сама программа во время
выполнения. В ней могут быть команды, загружающие необходимую
библиотеку только тогда, когда потребуется подпрограмма, содержащаяся
в ней.  Более, того, до запуска программы на исполнение может быть
вообще неизвестно, какие библиотеки программа будет загружать.

В частности, подобные возможности позволяют реализовать механизм
подключаемых модулей (так называемых плагинов), расширяющих
функционал программы.  Пользователь устанавливая модули может
расширять возможности приложения без модификации его исходного
кода. Программа сама найдёт модули на диске загрузит их в память и
будет использовать во время работы.

Одним из недостатков динамически связываемых библиотек является
проблема версий. Если разные программы используют разные версии одной
и той же библиотеки, возникает проблема, заключающаяся в том, что
нужно разместить на диске два файла с одинаковым именем. Эта проблема
решается различными способами. Например, в операционной системе Linux
номер версии добавляется к имени файла, а в Windows на уровне
операционной системы существует специальный механизм, позволяющий
определить требуемую версию и загрузить в память именно её. Сами
библиотеки располагаются в различных подпапках папки WinSxS, что
решает проблему конфликта имён.

Кроме того, в операционной системе Windows (в отличие от Linux) нет
стандартных мест в файловой системе, где располагаются библиотеки, что
иногда создаёт дополнительные сложности. % Какие

Практически все популярные языки программирования включают так
называемую \Term{Библиотека!стандартная}{стандартную библиотеку}. Она
не является частью языка, но содержит описание базовых, часто
встречающихся действий и обязательно присутствует в любой реализации
языка программирования.

% Стандартные функции операционной системы
