\chapter{Хранение данных}

\section{Типы данных и литералы}

Одним из важнейших понятий в программировании является понятие типа
данных.

\begin{defn}
  \Term{Тип данных}{Тип данных} — это совокупность множества
  допустимых значений какого-либо набора данных, множества допустимых
  над ним операций и способа его кодирования в памяти компьютера.
\end{defn}

Любые данные, хранящиеся в памяти какого-либо компьютера, относятся к
какому-либо типу. Это очевидно следует из того, что любые данные
должны быть каким-либо образом закодированы и преобразуются
компьютером с помощью некоторого набора операций.

Разнородные данные требуют разные объёмы памяти для хранения,
обрабатываются различным образом. Так, например, целые и вещественные
числа кодируются в процессорах архитектуры IA-32 различным образом,
поэтому для их обработки требуются различные машинные
команды. Информация о том, данные какого типа расположены в памяти,
может помочь компилятору сгенерировать более эффективный машинный
код. В связи с этим, практически во всех распространённых языках
программирования в явном виде присутствует концепция типов.

Из-за огромного разнообразия данных, которые требуется обрабатывать,
непосредственная поддержка каждого из них на аппаратном уровне,
очевидно, невозможна. Поэтому типы данных делят на:
\begin{itemize}
\item \Term{Тип данных!базовый}{базовые} (элементарные), поддержка
  которых существует в конкретной программно-аппаратной платформе
  (например, числа),
\item \Term{Тип данных!производный}{производные} (сложные), которые
  конструируются из базовых (например, векторы — последовательности
  чисел).
\end{itemize}

Базовыми типами для процессора архитектуры AMD64 являются, например,
1-, 2-, 4- и 8-байтовые целые числа, 10-байтовые числа с плавающей
точкой. Хотя на самом деле для кодирования любых данных, встречающихся
на практике, достаточно было бы только этих типов, для удобства многие
другие типы также относят к базовым.

Например, в платформе .NET присутствует следующие встроенные базовые
типы (в скобках приведены их названия в языке C\#):
\begin{itemize}
\item \Lst{Byte} (\Lst{byte}) — 1-байтовые целые со знаком
  ($-128\ldots127$);
\item \Lst{SByte} (\Lst{sbyte}) — 1-байтовые целые без знака
  ($0\ldots255$);
\item \Lst{Int16} (\Lst{short}) — 2-байтовые целые со знаком
  ($-32768\ldots32767$);
\item \Lst{UInt16} (\Lst{ushort}) — 2-байтовые целые без знака
  ($0\ldots65535$);
\item \Lst{Int32} (\Lst{int}) — 4-байтовые целые со знаком
  ($-2147483648\ldots2147483647$);
\item \Lst{UInt32} (\Lst{uint}) — 4-байтовые целые без знака
  ($0\ldots4294967295$);
\item \Lst{Int64} (\Lst{long}) — 8-байтовые целые со знаком
  ($-9223372036854775808\ldots9223372036854775807$);
\item \Lst{UInt64} (\Lst{ulong}) — 8-байтовые целые без знака
  ($0\ldots18446744073709551615$);
\item \Lst{Single} (\Lst{float}) — 4-байтовые вещественные числа с
  плавающей точкой (приблизительно
  $\pm1{,}5\times10^{-45}\ldots\pm3{,}4\times10^{38}\cup\{0\},$
  точность — 7 значащих десятичных цифр);
\item \Lst{Double} (\Lst{double}) — 8-байтовые вещественные числа с
  плавающей точкой (приблизительно
  $\pm5{,}0\times10^{-324}\ldots\pm1{,}7\times10^{308}\cup\{0\},$
  точность — 16 значащих десятичных цифр);
\item \Lst{Decimal} (\Lst{decimal}) — 16-байтовые вещественные
  числа, отличающееся тем, что представляет числа без округления
  (приблизительно
  $\pm1{,}0\times10^{-28}\ldots\pm7{,}9\times10^{28}\cup\{0\},$
  точность — 28 значащих десятичных цифр);
\item \Lst{Boolean} (\Lst{bool}) — логическое значение («ложь» либо
  «истина»);
\item \Lst{Char} (\Lst{char}) — 2-байтовые символы Юникода (Юникод
  — кодировка, позволяющая представить практически любой символ из
  существующих систем письменности);
\item \Lst{String} (\Lst{string}) — строки (последовательности
  символов, представляющие фрагменты текста);
\item \Lst{Object} (\Lst{object}) — вершина иерархии типов, не
  используется непосредственно;
\item \Lst{IntPtr, UIntPtr} (в C\# отсутствуют) — типы, позволяющие
  хранить адреса ячеек памяти.
\end{itemize}

\begin{table}
  \begin{centering}
    \begin{tabular}{|l|l|}
      \hline
      Имя           & Описание\\
      \hline
      \hline
      \Lst{byte}    & 1-байтовое целое число без знака\\
      \Lst{sbyte}   & 1-байтовое целое число со знаком\\
      \Lst{short}   & 2-байтовое целое число со знаком\\
      \Lst{ushort}  & 2-байтовое целое число без знака\\
      \Lst{int}     & 4-байтовое целое число со знаком\\
      \Lst{uint}    & 4-байтовое целое число без знака\\
      \Lst{long}    & 8-байтовое целое число со знаком\\
      \Lst{ulong}   & 8-байтовое целое число без знака\\
      \hline
      \Lst{float}   & Действительное число одинарной точности\\
      \Lst{double}  & Действительное число двойной точности\\
      \Lst{decimal} & Действительное число с фиксированной запятой\\
      \hline
      \Lst{bool}    & Логическое значение\\
      \hline
      \Lst{char}    & Одиночный символ в кодировке Юникод\\
      \Lst{string}  & Строка (последовательность символов)\\
      \hline
      \Lst{object}  & Базовый тип для остальных типов\\
      \hline
    \end{tabular}
  \par\end{centering}
  
  \caption{Встроенные типы языка C\#\label{tab:predefined-types}}
\end{table}

Эта система типов в платформе .NET носит название CTS (от англ. Common
Type System — общая система типов). Она во многом повторяет систему
типов процессоров распространённых архитектур, что сделано для
повышения производительности и упрощения работы компилятора.

Многие языки программирования (например, Haskell) имеют развитую
систему типов, которые образуют иерархию. Как правило иерархия
повторяет вложенность соответствующих множеств в математике. Например,
целые числа являются частным случаем вещественных чисел, что может
быть отражено в языке программирования. В процессорах архитектуры
IA-32, однако, подобные отношения не сохранены: целые и вещественные
числа кодируются различным образом и для операций над ними
используются различные машинные команды.

В языке C\# вершиной иерархии типов является тип \Lst{object}.  Сам
по себе для хранения данных он не используется, но может быть полезен,
если конкретный тип данных неизвестен. % boxing

Для того, чтобы работать с данными, должен существовать способ их
описания. Для этого используются литералы.

\begin{defn}
  \Term{Литерал}{Литерал} — неименованная константа какого-либо типа
  данных.
\end{defn}

Например, число 15 — это неименованная целочисленная константа, то
есть целочисленный литерал.

В языке C\# можно выделить следующие виды литералов:
\begin{enumerate}
\item целочисленные;
\item вещественные;
\item символьные;
\item строковые;
\item логические;
\item литерал null.
\end{enumerate}

Рассмотрим каждый из видов на примерах.

\Term{Литерал!целочисленный}{Целочисленные литералы} представляют
собой последовательность десятичных цифр, перед которой может стоять
знак «\Lst{+}» либо «\Lst{-}». По умолчанию литералы относятся к
типу \Lst{int}, но можно добавить к числу суффикс «\Lst{L}» для
указания на принадлежность к типу \Lst{long}. Также можно
использовать суффикс «\Lst{U}» для указания на то, что
целочисленный тип беззнаковый. % лучше заглавные

\begin{example}
  \Lst{+12} (тип \Lst{int}), \Lst{12U} (тип \Lst{uint}),
  \Lst{12L} (тип \Lst{long}), \Lst{12UL} (тип \Lst{ulong})
  — все эти литералы соответствуют числу двенадцать.
\end{example}

Также существует возможность использовать шестнадцатеричную форму
записи чисел. В этом случае необходимо добавить перед литералом
«\Lst{0x}».

\begin{example}
  \Lst{0x12} ($12_{16}=18_{10}$), \Lst{0x1B}
  ($\mathrm{1B}_{16}=27_{10}$), \Lst{0xAUL}
  ($\mathrm{A}_{16}=10_{10},$ тип \Lst{ulong}).
\end{example}

Особенностью \Term{Литерал!вещественный}{вещественных литералов}
является использование точки для отделения дробной части числа. По
умолчанию, вещественные литералы принадлежат типу \Lst{double}. Для
указания на принадлежность к типу \Lst{float} необходимо добавить
суффикс «\Lst{F}», к типу \Lst{decimal} — суффикс «\Lst{M}».

\begin{example}
  \Lst{12.3} (тип \Lst{double}), \Lst{12.3F} (тип
  \Lst{float}).
\end{example}

Для записи больших чисел можно использовать специальную нотацию вида:
«\Lst{\uline{число}}\Lst{E}\Lst{\uline{порядок}}».  Где
\Lst{\uline{число}} — вещественный литерал, а
\Lst{\uline{порядок}} — целочисленный. Эта запись соответствует
выражению
%$\text{\Lst{число}}\times10^{\text{\Lst{порядок}}}.$ %%
% FIXME!!!

\begin{example}
  \Lst{-12.3E2} ($-12{,}2\times10^{2}=1230{,}0$), \Lst{1.2E-2}
  ($1{,}2\times10^{-2}=0{,}012$).
\end{example}

\Term{Литерал!символьный}{Символьные литералы} представляют собой
отдельные символы, заключённые в одинарные кавычки. Тип символьных
литералов — \Lst{char}.

\begin{example}
  \texttt{'A'}, \Lst{'\%'}, \Lst{' '} — символы «A», «\%» и
  пробел соответственно.
\end{example}

Для записи самого символа одинарной кавычки и некоторых других
символов применяют экранирование — запись последовательности,
начинающейся с символа «\Lst{\textbackslash{}}» и соответствующей
отдельному специальному символу. Допустимые последовательности
приведены в таблице \ref{tab:escseq}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|l|}
      \hline 
      Последовательность & Символ\tabularnewline
      \hline 
      \hline 
      \Lst{\textbackslash '} & Одинарная кавычка («'»)\\
      \hline 
      \Lst{\textbackslash "} & Двойная кавычка («\textquotedbl»)\\
      \hline 
      \Lst{\textbackslash \textbackslash} & Обратная наклонная черта («\textbackslash»)\\
      \hline 
      \Lst{\textbackslash 0} & Символ с кодом 0 (признак конца строки)\\
      \hline 
      \Lst{\textbackslash a} & Звуковой сигнал\\
      \hline 
      \Lst{\textbackslash b} & Удаление последнего символа\\
      \hline 
      \Lst{\textbackslash f} & Переход на следующую страницу\\
      \hline 
      \Lst{\textbackslash n} & Переход в начало следующей строки\\
      \hline 
      \Lst{\textbackslash r} & Переход в начало текущей строки\\
      \hline 
      \Lst{\textbackslash t} & Переход к следующей позиции табуляции\\
      \hline 
      \Lst{\textbackslash v} & Переход на символ вниз\\
      \hline 
    \end{tabular}
  \end{centering}

  \caption{Специальные символы\label{tab:escseq}}
\end{table}

Также можно указать любой символ кодировки Юникод по его коду,
используя специальную последовательность вида
«\Lst{\textbackslash u\uline{код}}», где
\Lst{\uline{код}} — четыре шестнадцатеричные цифры кода символа.

\begin{example}
  \Lst{'\textbackslash u004A'} (символ «J»),
  \Lst{'\textbackslash u03BE'} (символ «$\xi$»).
\end{example}

\Term{Литерал!строковый}{Строковые литералы} — это последовательности
из нуля и более символов, заключённые в двойные кавычки. Строка из
нуля символов называется \Term{Строка!пустая}{пустой
  строкой}. Строковые литералы относятся к типу \Lst{string}.

\begin{example}
  \Lst{""} (пустая строка),
  \Lst{"abc"} (строка из трёх
  символов),
  \Lst{"abc\textbackslash n"} (строка,
  содержащая специальные символы).
\end{example}

\Term{Литерал!логический}{Логические литералы} отностяся к типу
\Lst{bool} и позволяют представить только одно из двух значений:
истина (литерал \Lst{true}) либо ложь (\Lst{false}).

Иногда возникает необходимость сохранить в переменной значение, не
принадлежащее типу. В этом случае в C\# можно использовать
\Term{Литерал!null}{литерал }\Lst{null}. % FiXME!!!
Для того, чтобы объект какого-либо типа
мог хранить это значение, необходимо использовать расширенный тип, имя
которого состоит из имени исходного типа и знака «?». Например,
«\Lst{int?}».

В языке C\#, как и во многих других языках, присутствуют различные
средства создания производных типов данных. В частности, распространёнными
средствами являются:
\begin{itemize}
\item перечисления — средство группировки констант по какому-либо
  признаку;
\item массивы — наборы пронумерованных данных одного типа (например,
  тип, описывающий результаты многочисленных измерений);
\item структуры — типы данных, позволяющие группировать объекты
  различных типов (например, тип, описывающий паспортные данные);
\item классы — дальнейшее развитие структур, одно из основных понятий
  объектно-ориентированного программирования
\item и другие.
\end{itemize}

Производные типы могут быть обобщёнными. Например, тип данных,
соответствующий списку значений, можн обобщить, не указывая конкретный
тип хранимых элементов, а используя его в качестве параметра T
некоторого обобщённого типа «Список элементов типа T». Использование
обобщений уменьшает размер программы, так как позволяет лишь один раз
описывать схожие действия для различных родственных типов.

Многие типы данных, используемые на практике, допускают взаимные
преобразования друг в друга. Так, например, величины типа \Lst{int}
могут при необходимости преобразовываться к типу
\Lst{double}. Подобные преобразования могут быть удобны, так как у
процессора архитектуры IA-32 нет команды для сложения целых и
вещественных чисел, только для сложения двух целых и двух
вещественных. Поэтому в выражении «1 + 1.0» оба аргумента должны быть
приведены к одному и тому же типу.

Преобразования типов могут быть как неявными, выполняемыми
автоматически компилятором, так и явными, по указанию программиста.

Неявные преобразования в некоторых случаях могут быть нежелательными,
и, кроме того, они усложняют контроль за типами данных в программе.  В
связи с этим, в некоторых языках неявные преобразования сведены к
минимуму или запрещены вовсе. Такие языки называются языками со
\Term{Типизация!строгая}{строгой типизацией}.

Описание типов данных — один из важнейших этапов работы над
программой.  Удачно выбранная система типов, хорошо соответствующая
предметной области, в которой разрабатывается программа, позволяет
значительно упростить процесс программирования и избежать многих
ошибок.

\section{Переменные и константы}

Все данные, которые используются в ходе выполнения программы должны
располагаться в памяти компьютера. Для доступа к данным в первых
программах использовались адреса ячеек памяти, но подобный подход
достаточно неудобен. Для упрощения работы с данными была введена
абстракция, пришедшая из математики, — понятие переменной.

\begin{defn}
  \Term{Переменная}{Переменная} — это объект в памяти компьютера,
  хранящий значение какого-либо типа.
\end{defn}

Для доступа к переменным, им присваиваются
\Term{Идентификатор}{идентификаторы} — имена, записываемые по
определённым правилам. Правила записи идентификаторов различаются в
различных языках. В некоторых из них разрешено использовать любые
последовательности практически любых символов кодировки Юникод, а в
некоторых — лишь единственную латинскую букву.

В языке C\# упрощённые правила записи идентификаторов выглядят
следующим образом. Идентификатор — это последовательность букв, цифр и
знаков подчёркивания, начинающаяся не с цифры. Вообще говоря, буквы
могут принадлежать любому алфавиту, описанному в Юникод, но
рекомендуется использовать только латинские буквы. Во-первых, это
упростит чтение и редактирование программы иноязычными разработчиками,
во-вторых, некоторые символы в различных алфавитах выглядят одинаково
(например латинская «o» и кириллическая «о»), что может вызвать
путаницу, и наконец, поддержка нелатинских букв в идентификаторах
может отсутствовать в компиляторе.

Регистр символов имеет значение. Поэтому, к примеру, переменные
«\Lst{a}» и «\Lst{A}» считаются различными.

Желательно давать переменным имена, отражающие суть хранимых в них
данных. Это значительно упрощает чтение программы. Например, для
переменной, хранящей количество значений какой-либо величины, имя
«\Lst{NumberOfValues}» является более предпочтительным, чем
«\Lst{x}».

Любое значение, хранимое в переменной относится к какому-либо типу.
Существует несколько подходов к организации связи переменной и типа
данных в языке.

При \Term{Типизация!статическая}{статической типизации} каждая
переменная связывается с типом данных на этапе трансляции программы не
может изменять свой тип в дальнейшем. Если указать, что переменная
хранит целочисленные значения, то в неё в дальнейшем невозможно будет
поместить что-либо другое.  К статически типизированным языкам
относятся C++, Pascal, Java и другие.

В языках с \Term{Типизация!динамическая}{динамической типизацией} тип
переменной определяется во время выполнения программы в момент
присваивания ей значения. Это позволяет хранить в одной и той же
переменной значения различных типов.  Динамическая типизация
присутствует в таких языках, как Python, PHP, Ruby и т.~д.

Язык C\# использует смешанный подход. С одной стороны, на этапе
трансляции проводятся проверки типов как при статической типизации. С
другой стороны, если объявить переменную с использованием ключевого
слова \Lst{dynamic} вместо имени типа, то её тип будет определяться
динамически по хранимому значению. Однако, эта возможность на практике
используется сравнительно редко.

Статическая типизация имеет ряд преимуществ. В частности, она
позволяет уже на этапе компиляции программы обнаруживать ряд ошибок,
таких как присваивание значения не той переменной. Кроме того, в
отличие от динамической типизации, она не требует выполнения проверок
во время выполнения программы, что уменьшает время работы.

В C\# для того, чтобы связать переменную с типом и выделить под неё
место в памяти, необходимо её
\Term{Объявление!переменной}{объявить}. Все переменные в программе
должны быть объявлены. Формат объявления:

\begin{center}
  \Lst{\uline{тип}}\Lst{ }\Lst{\uline{список переменных}}\Lst{;}
\par\end{center}

Здесь \Lst{\uline{список переменных}} — это перечень
идентификаторов через запятую.

\begin{example}
  Переменные \Lst{a} и \Lst{b} после приведённого ниже
  объявления будут иметь тип \Lst{int}, а переменная \Lst{c} —
  \Lst{double}.
\begin{lstlisting}
int a, b;
double c;
\end{lstlisting}
\end{example}

Переменную при объявлении можно
\Term{Инициализация}{инициализировать}, то есть присвоить ей
какое-либо значение. для этого нужно после соответствующего
идентификатора добавить

\begin{center}
  \Lst{= }\Lst{\uline{значение}}
\par\end{center}

После знака «=» может стоять литерал или другая переменная, уже имеющая
значение.

\begin{example}
  Переменная \Lst{g} инициализируется значением $9{,}81,$ а
  переменные \Lst{x} и \Lst{y} не инициализированы.

\begin{lstlisting}
double x, g=9.81, y;
\end{lstlisting}
\end{example}

Если переменная инициализируется, то существует возможность не
указывать тип переменной, записав вместо него ключевое слово
\Lst{var}. В этом случае переменная получит тип, совпадающий с
типом присваиваемого значения. При этом сохраняется статическая
типизация, так как переменная связывается с некоторым типом, хоть он и
не указан явно.

\begin{example}
Переменная \Lst{w} получает тип \Lst{double}, так как к нему
относится литерал \Lst{12.3}.

\begin{lstlisting}
var w = 1.23;
\end{lstlisting}
\end{example}

После объявления переменной появляется возможность использовать
указанный идентификатор, однако не всегда объявление позволяет
утверждать, что память под объект выделена.

В языке C\# все типы данных делятся на \Term{Тип
  данных!значимый}{значимые} и \Term{Тип данных!ссылочный}{ссылочные}.
К значимым типам относятся целочисленные и вещественные типы,
логический тип, структуры и перечисления. Все остальные типы относятся
к ссылочным.

Переменная значимого типа хранит непосредственно значение указанного
типа, и память под это значение выделяется при
объявлении. Идентификатор переменной связывается с выделенным участком
памяти и по нему можно получить доступ к хранимому значению.

Переменная ссылочного типа хранит только ссылку на область памяти, где
располагается значение. При объявлении память выделяется только для
ссылки, а память для значения должна быть выделена отдельно. В языке
C\# для выделения памяти используется операция \Lst{new},
выделяющая область памяти под объект указанного типа и возвращающая
ссылку на неё.

\begin{example}
Переменная \Lst{x} — ссылка на объект типа
\Lst{System.Drawing.Bitmap(100, 100)}, соответствующего
изображениям размера $100\times100$ пикселей.  Переменная \Lst{y}
ссылается на тот же самый объект, так как была инициализирована
ссылкой \Lst{x}. В частности, отсюда следует, что изменение
\Lst{x} повлечёт за собой изменение \Lst{y}.

\begin{lstlisting}
var x = new System.Drawing.Bitmap(100, 100);
var y = x;
\end{lstlisting}
\end{example}

Операции, позволяющей указать, что некоторая область памяти не
используется и её можно освободить, в C\# нет. Это связано с тем, что
виртуальная машина следит за ссылками на каждую выделенную область
памяти, и если ссылок на какую-то область больше нет, она
освобождается автоматически.  Этим занимается специальная подсистема,
называемая \emph{сборщиком мусора} (GC — garbage collector). Его
поддержка присутствует во многих языках программирования, таких, как
Python, Java, Lisp и т.~д.

Для повышения быстродействия разработчики языка могут отказаться от
сборщика мусора, но в этом случае возникает опасность появления
областей, помеченных как занятые, но не используемых, из-за ошибок
программиста, забывшего вставить команду на освобождение памяти. Такая
ситуация называется \Term{Утечка памяти}{утечкой памяти} (memory
leak).

Если значение переменной не должно меняться во время выполнения
программы, то её можно объявить как константу, добавив перед
объявлением \Lst{const}.

\begin{example}
Константа $g=9{,}81.$

\begin{lstlisting}
const double g = 9.81;
\end{lstlisting}
\end{example}

Константы обязательно должна быть инициализированы, так как в
дальнейшем присвоить ей какое-либо значение невозможно.

\section{Виды памяти}

Из-за технических ограничений, существующих в настоящее время, память
компьютера имеет разнородную структуру. Программы и данные, с которыми
работает компьютер, должны храниться в \Term{Память
  оперативная}{оперативной памяти}, но она, как правило, работает
медленнее, чем процессор. Поэтому процессор проводит вычисления над
данными, расположенными в особых ячейках, расположенных внутри него —
\Term{Регистр процессора}{регистрах}. Их количество ограничено, но
доступ к ним осуществляется за время, сравнимое со временем выполнения
одной команды.

Так как регистров мало, то для ускорения доступа к оперативной памяти,
часто используемые данные из неё копируются в \Term{Кэш
  процессора}{кэш процессора}.  Этот вид памяти работает быстрее, чем
оперативная память, но медленнее, чем регистры. С другой стороны, его
объём больше, чем объём данных, которые можно разместить в регистрах.

С другой стороны, оперативная память достаточно дорога и, как правило,
требует постоянного электропитания, поэтому большие бъёмы данных
хранят во внешней памяти — жёстких дисках, флеш-памяти, оптических
дисках и т.~д.

Таким образом, все рассмотренные виды памяти образуют следующую иерархию:
\begin{enumerate}
\item регистры (суммарный объём обычно не превышает сотен байт);
\item кэш процессора (до нескольких мегабайт);
\item оперативная память (порядка нескольких гигабайт);
\item внешняя память (объём может значительно отличаться, порядка
  сотен гигабайт — нескольких терабайт).
\end{enumerate}

Этот список упорядочен по возрастанию объёма и уменьшению быстродействия.

Разница во времени доступа к регистрам и внешней памяти огромна и
может отличаться на несколько порядков.

При написании программ обычно не требуется знать, где расположены
данные: в регистрах, в кэше или оперативной памяти. Компилятор сам
распределяет данные. Можно считать, что все объекты, с которыми
работает программа, располагаются в оперативной памяти.

С другой стороны
