\chapter{Хранение данных}

\section{Типы данных и литералы}

\Par{Тип данных}

Одним из важнейших понятий в программировании является понятие типа
данных.

\begin{defn}
  \Term{Тип данных}{Тип данных} — это совокупность, включающая:
  \begin{itemize}
    \item множество допустимых значений какого-либо набора данных,
    \item множество допустимых над ним операций,
    \item смысл данных,
    \item способ их представления в памяти компьютера.
  \end{itemize}
\end{defn}

Любые данные, хранящиеся в памяти компьютера, так или иначе относятся
к какому-либо типу.

Разнородные данные требуют разных объёмов памяти для хранения,
обрабатываются различным образом. Например, целые и вещественные числа
кодируются в процессорах архитектуры IA-32 различным образом. Поэтому
для их обработки требуются различные машинные команды, даже если эти
числа равны.

Информация о том, данные какого типа расположены в памяти, может
помочь компилятору сгенерировать более эффективный машинный код. В
связи с этим, во многих распространённых языках программирования в
явном виде присутствует концепция типов.

\Par{Простые и сложные типы}

Из-за огромного разнообразия данных, которые требуется обрабатывать,
непосредственная поддержка каждого из них на аппаратном уровне,
очевидно, невозможна. Поэтому типы данных делят на две категории.

\begin{itemize}
\item \Term{Тип данных!простой}{Простые типы} не имеющие внутренней
  структуры, доступной программисту. Обычно поддерживаются
  непосредственно конкретной программно-аппаратной платформой.

  Например, числа обычно относят к простым типам.

\item \Term{Тип данных!сложный}{Сложные типы}, которые конструируются
  из базовых.

  Например, вектор можно представить как последовательность чисел, то
  есть он обладает внутренней структурой.
\end{itemize}

Работа программиста состоит во многом в описании данных,
присутствующих в стоящей задаче. Для этого необходимо описать
соответствующие сложные типы, которые конструируются из простых
средствами языка програмирования.

Описание типов данных — один из важнейших этапов работы над
программой. Удачно выбранная система типов, хорошо соответствующая
предметной области, в которой разрабатывается программа, позволяет
значительно упростить процесс программирования и избежать многих
ошибок.

\Par{Базовые типы}

Программно-аппаратные платформы и языки программирования предоставляют
программисту некоторый набор предопределённых \Term{Тип
  данных!базовый}{базовых (примитивных) типов}.

Например, базовыми типами для процессора архитектуры AMD64 являются
1-, 2-, 4- и 8-байтовые целые числа, 10-байтовые числа с плавающей
точкой. Хотя на самом деле для кодирования любых данных, встречающихся
на практике, достаточно было бы только этих типов, для удобства многие
другие типы в высокоуровневых языках программирования также относят к
базовым.

Тип данных, базовый в одном языке, может не являться базовым в
другом. Например, в языке Matlab комплексное число — базовый тип, а в
языке Pascal его приходится реализовывать программисту.

В частности, в языке C\# присутствует ограниченный набор базовых
типов, которые приведены в таблице~\ref{tab:predefined-types}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|l|l|}
      \hline
      Имя           & Описание\\
      \hline
      \hline
      \Lst{byte}    & 1-байтовое целое число без знака\\
      \Lst{sbyte}   & 1-байтовое целое число со знаком\\
      \Lst{short}   & 2-байтовое целое число со знаком\\
      \Lst{ushort}  & 2-байтовое целое число без знака\\
      \Lst{int}     & 4-байтовое целое число со знаком\\
      \Lst{uint}    & 4-байтовое целое число без знака\\
      \Lst{long}    & 8-байтовое целое число со знаком\\
      \Lst{ulong}   & 8-байтовое целое число без знака\\
      \hline
      \Lst{float}   & Действительное число одинарной точности\\
      \Lst{double}  & Действительное число двойной точности\\
      \Lst{decimal} & Действительное число с фиксированной запятой\\
      \hline
      \Lst{bool}    & Логическое значение\\
      \hline
      \Lst{char}    & Одиночный символ в кодировке Юникод\\
      \Lst{string}  & Строка (последовательность символов)\\
      \hline
      \Lst{object}  & Тип, являющийся основой для остальных типов\\
      \hline
    \end{tabular}\par
  \end{centering}
  
  \caption{Базовые типы языка C\#\label{tab:predefined-types}}
\end{table}

\Par{Классификация типов языка C\#}

Базовые типы языка C\# можно условно разделить на следующие группы.

\begin{itemize}
\item \Term{Тип данных!целочисленный}{Целочисленные типы},
  соответствующие различным диапазонам целых чисел.
\item \Term{Тип данных!вещественный}{Вещественные типы}, позоляющие
  приближённо описывать действительные числа с различной точностью.
\item \Term{Тип данных!логический}{Логический тип}.
\item \Term{Тип данных!символьный}{Символьный} и \Term{Тип
  данных!строковый}{строковый типы}, используемые для хранения
  фрагментов текста.
\item \Term{Тип данных!object}{Тип \Lst{object}} — вершина иерархии
  типов, не используется непосредственно.
\end{itemize}

Надо заметить, что эта классификация несколько отличается от
классификации, приведённой в стандарте на язык C\#.

\Par{Целочисленные типы}

Целочисленные типы составляют наиболее обширный класс базовых
типов. Это связано с тем, что целые числа — основной тип данных,
обрабатываемых процессором. Более того процессоры многих архитектур (в
основном, микроконтроллеры) поддерживают только целые числа.

Целые числа в памяти компьютера обычно занимают 1, 2, 4 или
8~байт. Также они могут рассматриваться как неотрицательные числа или
числа со знаком. Таким образом, получаем 8 целочисленных типов,
приведённых в таблице~\ref{tab:integral-types}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|l|c|}
      \hline
      Имя           & Диапазон\\
      \hline
      \hline
      \Lst{byte}    & $-128\ldots127$\\
      \Lst{sbyte}   & $0\ldots255$\\
      \Lst{short}   & $-32768\ldots32767$\\
      \Lst{ushort}  & $0\ldots65535$\\
      \Lst{int}     & $-2147483648\ldots2147483647$\\
      \Lst{uint}    & $0\ldots4294967295$\\
      \Lst{long}    & $-9223372036854775808\ldots9223372036854775807$\\
      \Lst{ulong}   & $0\ldots18446744073709551615$\\
      \hline
    \end{tabular}\par
  \end{centering}
  
  \caption{Диапазоны значений целочисленных типов\label{tab:integral-types}}
\end{table}

Следует помнить о диапазонах представимых целых чисел. Например, число
$-128$ можно хранить в переменной типа \Lst{byte}, но вычислить его
модуль и поместить в ту же переменную не получится.

\Par{Вещественные типы}

Реализация вещественных типов с плавающей запятой часто представлена на
аппаратном уровне. Существует стандарт IEEE~754-2008 описывающий
формат преставления вещественных чисел половинной, одинарной, двойной
и четверной точности. В языке C\# базовыми явзяются числа одинарной
(тип \Lst{float}) и двойной точности (\Lst{double}) — их достаточно
для подавляющего большинства приложений.

Кроме самих чисел из различных диапазонов стандарт предусматривает
возможность работы с положительной и отрицательной бесконечностями и
так называемым «не числом» (NaN — от англ. not a
number). Положительная бесконечность получается, например, при делении
положительного числа на ноль. Результатом вычисления $\frac00$ будет
NaN.

Рассмотренные вещественные типы хранят значения в приближённом
виде. Это связано с ограничениями на количество хранимых знаков
мантиссы и экспоненты. Поэтому не рекомендуется сравнивать между собой
вещественные числа.

Например, результат суммирования пятидесяти слагаемых, равных~$0{,}1$,
не будет равен~$5{,}0$ при использовании чисел с плавающей
точкой. Дело в том, что число~$0{,}1$ непредставимо в двоичной системе
в виде конечной дроби. Часть значащих цифр отбрасывается, и
вместо~$0{,}1$ в вычислениях участвует другое число, хоть и
отличающееся на чрезвычайно малую величину.

Хоть ошибки округления и малы, они имеют свойство накапливаться, что
может дать совершенно неверный результат. Примером может служить
\Term{Последовательность Мюллера}{последовательность Мюллера},
определяемая рекуррентным соотношением

\begin{eqnarray*}
f(y, z) &=& 108 - \frac{815 - \frac{1500}{z}}{y};\\
x_0 &=& 4;\\
x_1 &=& 4{,}25;\\
x_i &=& f(x_{i-1}, x_{i-2}).
\end{eqnarray*}

Если запрограммировать вычисления с использованием плавающей точки, то
в результате последовательность достаточно быстро начнёт сходиться к
100, однако правильный ответ равен 5.

Если необходима сохранность каждой значащей десятичной цифры с
заданной точностью, можно использовать тип \Lst{decimal}. Однако он
менее эффективен, так как реализован не аппаратно, а программно.

Перечисленные типы, дапазоны их допустимых значений и количество
хранимых значащих цифр мантиссы приведены в
таблице~\ref{tab:real-types}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|l|c|c|}
      \hline
      Имя            & Диапазон & Точность, цифр\\
      \hline
      \hline
      \Lst{float}    &
      $\pm1{,}5\times10^{-45}\ldots\pm3{,}4\times10^{38}\cup\{0\}$   &
      7\\
      \Lst{double}   &
      $\pm5{,}0\times10^{-324}\ldots\pm1{,}7\times10^{308}\cup\{0\}$ &
      15--16\\
      \Lst{decimal}  &
      $\pm1{,}0\times10^{-28}\ldots\pm7{,}9\times10^{28}\cup\{0\}$   &
      28\\
      \hline
    \end{tabular}\par
  \end{centering}
  
  \caption{Диапазоны значений типов, описывающих действительные
    числа\label{tab:real-types}}
\end{table}

\Par{Логический тип}

Логический тип данных \Lst{bool} включает лишь два значения — истину и
ложь. Он может быть полезен для хранения информации об объектах,
имеющих только два состояния. Удобство его заключается также в том,
что в C\# присутствуют логические операции, такие как конъюнкция,
дизъюнкция и инверсия.

\Par{Символьный тип}

Символьный тип \Lst{char} предназначен для хранения отдельных символов
— букв, цифр, знаков препинания и других. Символ может быть любым,
предусмотренным стандартом Юникод. Это позволяет хранить в памяти
буквы практически любого алфавита, иероглифы и специальные знаки.

Также к символам относят так называемые \Term{Управляющая
  последовательность}{управляющие поледовательности} — символы,
которые не отображаются на экране, но выполняют какие-либо
действия. Например, к ним относятся символ перехода на новую строку,
символ табуляции и так далее.

\Par{Строковый тип}

Для хранения фрагментов текста длиннее одного символа используется так
называемый строковый тип \Lst{string}. Он предназначен для хранения
\Term{Строка}{строк} — неизменяемых последовательностей символов
Юникода.

\Par{Тип \Lst{object}}

Многие языки программирования (например, Haskell) имеют развитую
систему типов, которые образуют иерархию. Как правило иерархия
повторяет вложенность соответствующих множеств в математике. Например,
целые числа являются частным случаем вещественных чисел, что может
быть отражено в языке программирования.

В языке C\# вершиной иерархии типов является тип \Lst{object}.  Сам
по себе для хранения данных он не используется, но может быть полезен,
если конкретный тип данных неизвестен.

\Par{Литералы}

Для того, чтобы работать с данными, должен существовать способ их
описания. Для этого используются литералы.

\begin{defn}
  \Term{Литерал}{Литерал} — неименованная константа какого-либо типа
  данных.
\end{defn}

Например, число $15$ — это неименованная целочисленная константа, то
есть целочисленный литерал.

В языке C\# можно выделить следующие виды литералов:
\begin{enumerate}
\item целочисленные;
\item вещественные;
\item символьные;
\item строковые;
\item логические;
\item литерал null.
\end{enumerate}

Примеры литералов приведены в таблице~\ref{tab:literal-example}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|c|c|}
      \hline 
      Литерал & Значение & Тип \\
      \hline 
      \hline 
      \Lst{+12} & $12$ & \Lst{int}\\
      \hline 
      \Lst{12U} & $12$ & \Lst{uint}\\
      \hline 
      \Lst{-12L} & $-12$ & \Lst{long}\\
      \hline 
      \Lst{-12UL} & $-12$ & \Lst{ulong}\\
      \hline 
      \Lst{0x12} & $12_{16}=18_{10}$ & \Lst{int}\\
      \hline 
      \Lst{0x1BUL} & $1\mathrm{B}_{16}=27_{10}$ & \Lst{ulong}\\
      \hline 
      \Lst{12.3} & $12{,}3$ & \Lst{double}\\
      \hline 
      \Lst{12.3F} & $12{,}3$ & \Lst{float}\\
      \hline 
      \Lst{-12.3E2} & $-12{,}3 \times 10^2 = -1230$ & \Lst{double}\\
      \hline 
      \Lst{1.2E-2F} & $1{,}2 \times 10^{-2} = 0{,}012$ & \Lst{float}\\
      \hline 
      \Lst{'A'} & «A» & \Lst{char}\\
      \hline 
      \Lst{"Abc"} & «Abc» & \Lst{string}\\
      \hline 
      \Lst{'\textbackslash u004A'} & «J» & \Lst{char}\\
      \hline 
      \Lst{"\textbackslash u03BE"} & «$\xi$» & \Lst{string}\\
      \hline 
    \end{tabular}\par
  \end{centering}

  \caption{Примеры литералов\label{tab:literal-example}}
\end{table}

Рассмотрим каждый из видов на примерах.

\Par{Целочисленные литералы}

\Term{Литерал!целочисленный}{Целочисленные литералы} представляют
собой последовательность десятичных цифр, перед которой может стоять
знак «\Lst{+}» либо «\Lst{-}». По умолчанию литералы относятся к
типу \Lst{int}, но можно добавить к числу суффикс «\Lst{L}» для
указания на принадлежность к типу \Lst{long}. Также можно
использовать суффикс «\Lst{U}» для указания на то, что
целочисленный тип беззнаковый. (Для написания суффиксов лучше
использовать заглавные буквы: например, буква L и цифра 1 в некоторых
шрифтах очень похожи и могут привести к путанице.)

Также существует возможность использовать шестнадцатеричную форму
записи чисел. В этом случае необходимо добавить перед литералом
«\Lst{0x}».

\Par{Вещественные литералы}

Особенностью \Term{Литерал!вещественный}{вещественных литералов}
является использование точки для отделения дробной части числа. По
умолчанию, вещественные литералы принадлежат типу \Lst{double}. Для
указания на принадлежность к типу \Lst{float} необходимо добавить
суффикс «\Lst{F}», к типу \Lst{decimal} — суффикс «\Lst{M}».

Для записи очень больших и очень малых чисел можно использовать
специальную нотацию вида: «\Lst{\uline{число}E\uline{порядок}}».
Здесь \Lst{\uline{число}} — вещественный литерал, а
\Lst{\uline{порядок}} — целочисленный. Эта запись соответствует
выражению
\[\textrm{\Lst{\uline{число}}} \times 10^{\textrm{\Lst{\uline{порядок}}}}.\]

\Par{Символьные литералы}

\Term{Литерал!символьный}{Символьные литералы} представляют собой
отдельные символы, заключённые в одинарные кавычки. Тип символьных
литералов — \Lst{char}.

Для записи самого символа одинарной кавычки и некоторых других
символов применяют экранирование — запись последовательности,
начинающейся с символа «\Lst{\textbackslash{}}» и соответствующей
отдельному специальному символу. Допустимые последовательности
приведены в таблице \ref{tab:escseq}.

\begin{table}
  \begin{centering}
    \begin{tabular}{|c|l|}
      \hline 
      Последовательность & Символ\\
      \hline 
      \hline 
      \Lst{\textbackslash '} & Одинарная кавычка («'»)\\
      \hline 
      \Lst{\textbackslash "} & Двойная кавычка («\textquotedbl»)\\
      \hline 
      \Lst{\textbackslash \textbackslash} & Обратная наклонная черта («\textbackslash»)\\
      \hline 
      \Lst{\textbackslash 0} & Символ с кодом 0 (признак конца строки)\\
      \hline 
      \Lst{\textbackslash a} & Звуковой сигнал\\
      \hline 
      \Lst{\textbackslash b} & Удаление последнего символа\\
      \hline 
      \Lst{\textbackslash f} & Переход на следующую страницу\\
      \hline 
      \Lst{\textbackslash n} & Переход в начало следующей строки\\
      \hline 
      \Lst{\textbackslash r} & Переход в начало текущей строки\\
      \hline 
      \Lst{\textbackslash t} & Переход к следующей позиции табуляции\\
      \hline 
      \Lst{\textbackslash v} & Переход на символ вниз\\
      \hline 
    \end{tabular}\par
  \end{centering}

  \caption{Специальные символы\label{tab:escseq}}
\end{table}

Также можно указать любой символ кодировки Юникод по его коду,
используя специальную последовательность вида
«\Lst{\textbackslash u\uline{код}}», где
\Lst{\uline{код}} — четыре шестнадцатеричные цифры кода символа.

\Par{Строковые литералы}

\Term{Литерал!строковый}{Строковые литералы} — это последовательности
из нуля и более символов, заключённые в двойные кавычки. Строка из
нуля символов называется \Term{Строка!пустая}{пустой
  строкой}. Строковые литералы относятся к типу \Lst{string}.

Если в строке встречаются символы обратной косой черты, то их
приходится удваивать, так как они имеют специальный смысл. При большом
их количестве это снижает читаемость текста. В таком случае можно
использовать \Term{Литерал!строковый!буквальный}{буквальные строковые
  литералы}. Они записываются аналогично, но перед первой кавычкой
ставится символ «@».

Например, следующие две строки эквивалентны:
\begin{itemize}
\item\Lst{"c:\textbackslash\textbackslash Documents\textbackslash\textbackslash
  text.txt"}
\item\Lst{@"c:\textbackslash Documents\textbackslash text.txt"}
\end{itemize}

Чтобы включить в состав такого литерала сам символ двойной кавычки,
его нужно удвоить.

Недостатком буквальных строковых литералов является то, что в них
нельзя использовать управляющие последовательности.

\Par{Логические литералы}

\Term{Литерал!логический}{Логические литералы} относятся к типу
\Lst{bool} и позволяют представить только одно из двух значений:
истина (литерал \Lst{true}) либо ложь (\Lst{false}).

\Par{Литерал \Lst{null}}

\Term{Литерал!null}{Литерал }\Lst{null} используется в качестве
некоторого «нулевого» значения ссылки на область в памяти, не
указывающего ни на один существующий объект. Его используют, например,
если возникает необходимость сохранить в переменной значение, не
принадлежащее множеству допустимых значений её типа.

Не все типы включают значение \Lst{null} как допустимое. Однако такая
возможность появляется, если к имени типа добавить знак «?». Например,
тип «\Lst{int?}» позволяет хранить не только целые числа, но и
\Lst{null}.

\Par{Производные типы}

В языке C\#, как и во многих других языках, присутствуют различные
средства создания производных типов данных. В частности, распространёнными
средствами являются:
\begin{itemize}
\item перечисления — средство группировки констант по какому-либо
  признаку;
\item массивы — наборы пронумерованных данных одного типа (например,
  тип, описывающий результаты многочисленных измерений);
\item структуры — типы данных, позволяющие группировать объекты
  различных типов (например, тип, описывающий паспортные данные);
\item классы — дальнейшее развитие структур, одно из основных понятий
  объектно-ориентированного программирования
\item и другие.
\end{itemize}

\Par{Обобщённые типы}

Производные типы могут быть обобщёнными. Например, тип данных,
соответствующий списку значений, можно обобщить, не указывая конкретный
тип хранимых элементов, а используя его в качестве параметра T
некоторого обобщённого типа «Список элементов типа T». Использование
обобщений уменьшает размер программы, так как позволяет лишь один раз
описывать схожие действия для различных родственных типов.

Параметр обобщённого типа записывается в угловых скобках. Например,
тип \Lst{List} — это обобщённый тип, соответствующий спискам значений
некоторого типа. Тогда \Lst{List<int>} — список значений типа
\Lst{int}.

\Par{Преобразования типов}

Многие типы данных, используемые на практике, допускают взаимные
преобразования друг в друга. Так, например, величины типа \Lst{int}
могут при необходимости преобразовываться к типу
\Lst{double}. Подобные преобразования часто необходимы, так как нужно
однозначно определить тип результата. Например, в выражении «1 + 1.0»
оба аргумента должны быть приведены к одному и тому же типу. Обычно
берут тип, у которого больший диапазон допустимых значений. Для C\# в
рассмотренном примере это тип \Lst{double}. Однако, есть языки, в
которых запрещено складывать целые и вещественные числа без указания,
какой тип считать более общим.

Преобразования типов могут быть как неявными, выполняемыми
автоматически компилятором, так и явными, по указанию программиста.

Неявные преобразования в некоторых случаях могут быть нежелательными,
и, кроме того, они усложняют контроль за типами данных в программе.  В
связи с этим, в некоторых языках неявные преобразования сведены к
минимуму или запрещены вовсе. Такие языки называются языками с
\Term{Типизация!сильная}{сильная типизацией}.

\section{Переменные и константы}

\Par{Переменные}

Все данные, которые используются в ходе выполнения программы должны
располагаться в памяти компьютера. Для доступа к данным в первых
программах использовались адреса ячеек памяти, но подобный подход
достаточно неудобен. Для упрощения работы с данными была введена
абстракция, пришедшая из математики, — понятие переменной.

\begin{defn}
  \Term{Переменная}{Переменная} — это объект в памяти компьютера,
  хранящий значение какого-либо типа.
\end{defn}

\Par{Идентификаторы}

Для доступа к переменным, им присваиваются
\Term{Идентификатор}{идентификаторы} — имена, записываемые по
определённым правилам. Правила записи идентификаторов различаются в
различных языках. В некоторых из них разрешено использовать любые
последовательности практически любых символов кодировки Юникод, а в
некоторых — лишь единственную латинскую букву.

В языке C\# упрощённые правила записи идентификаторов выглядят
следующим образом. Идентификатор — это последовательность букв, цифр и
знаков подчёркивания, начинающаяся не с цифры. Вообще говоря, буквы
могут принадлежать любому алфавиту, описанному в Юникод, но
рекомендуется использовать только латинские буквы. Во-первых, это
упростит чтение и редактирование программы иноязычными разработчиками,
во-вторых, некоторые символы в различных алфавитах выглядят одинаково
(например латинская «o» и кириллическая «о»), что может вызвать
путаницу, и, наконец, поддержка нелатинских букв в идентификаторах
может отсутствовать в компиляторе.

Регистр символов имеет значение. Поэтому, к примеру, переменные
\Lst{a} и \Lst{A} считаются различными.

Желательно давать переменным имена, отражающие суть хранимых в них
данных. Это значительно упрощает чтение программы. Например, для
переменной, хранящей количество значений какой-либо величины, имя
\Lst{NumberOfValues} является более предпочтительным, чем
\Lst{x}.

В качестве иентификаторов нельзя использовать ключевые слова
языка. Поэтому, например, нельзя дать переменной имя \Lst{int}.

\Par{Виды типизации}

Любое значение, хранимое в переменной относится к какому-либо типу.
Существует несколько подходов к организации связи переменной и типа
данных в языке.

При \Term{Типизация!статическая}{статической типизации} каждая
переменная связывается с типом данных на этапе трансляции программы и
не может изменять свой тип в дальнейшем. Если указать, что переменная
хранит целочисленные значения, то в неё в дальнейшем невозможно будет
поместить что-либо другое.  К статически типизированным языкам
относятся C++, Pascal, Java и другие.

В языках с \Term{Типизация!динамическая}{динамической типизацией} тип
переменной определяется во время выполнения программы в момент
присваивания ей значения. Это позволяет хранить в одной и той же
переменной значения различных типов.  Динамическая типизация
присутствует в таких языках, как Python, PHP, Ruby и т.~д.

Язык C\# использует смешанный подход. С одной стороны, на этапе
трансляции проводятся проверки типов как при статической типизации. С
другой стороны, если объявить переменную с использованием ключевого
слова \Lst{dynamic} вместо имени типа, то её тип будет определяться
динамически по хранимому значению. Однако, эта возможность на практике
используется сравнительно редко.

Статическая типизация имеет ряд преимуществ. В частности, она
позволяет уже на этапе компиляции программы обнаруживать ряд ошибок,
таких как присваивание значения не той переменной. Кроме того, в
отличие от динамической типизации, она не требует выполнения проверок
во время выполнения программы, что уменьшает время работы.

\Par{Объявление переменных}

В C\# для того, чтобы связать переменную с типом и выделить под неё
место в памяти, необходимо её
\Term{Объявление!переменной}{объявить}. Все переменные в программе
должны быть объявлены. Формат объявления:

\begin{center}
  \Lst{\uline{тип} \uline{список переменных};}
  \par
\end{center}

Здесь \Lst{\uline{список переменных}} — это перечень
идентификаторов через запятую.

\begin{example}
  Переменные \Lst{a} и \Lst{b} после приведённого ниже
  объявления будут иметь тип \Lst{int}, а переменная \Lst{c} —
  \Lst{double}.

\begin{lstlisting}
int a, b;
double c;
\end{lstlisting}
\end{example}

\Par{Инициализация}

Переменную при объявлении можно
\Term{Инициализация}{инициализировать}, то есть присвоить ей
какое-либо значение. для этого нужно после соответствующего
идентификатора добавить

\begin{center}
  \Lst{= \uline{значение}}
  \par
\end{center}

После знака «=» может стоять литерал или другая переменная, уже имеющая
значение.

\begin{example}
  Переменная \Lst{y} инициализируется значением $17{,}32,$ а
  переменные \Lst{x} и \Lst{z} не инициализированы.

\begin{lstlisting}
double x, g=17.32, y;
\end{lstlisting}
\end{example}

Если переменная инициализируется, то существует возможность не
указывать тип переменной, записав вместо него ключевое слово
\Lst{var}. В этом случае переменная получит тип, совпадающий с
типом присваиваемого значения. При этом сохраняется статическая
типизация, так как переменная связывается с некоторым типом, хоть он и
не указан явно.

\begin{example}
  Переменная \Lst{w} получает тип \Lst{double}, так как к нему
  относится литерал \Lst{1.23}.
  
\begin{lstlisting}
var w = 1.23;
\end{lstlisting}
\end{example}

После объявления переменной появляется возможность использовать
указанный идентификатор, однако не всегда объявление позволяет
утверждать, что память под объект выделена.

\Par{Значимые и ссылочные типы}

В языке C\# все типы данных делятся на \Term{Тип
  данных!значимый}{значимые} и \Term{Тип данных!ссылочный}{ссылочные}.
К значимым типам относятся целочисленные и вещественные типы,
логический тип, структуры и перечисления. Все остальные типы относятся
к ссылочным.

Переменная значимого типа хранит непосредственно значение указанного
типа, и память под это значение выделяется при
объявлении. Идентификатор переменной связывается с выделенным участком
памяти и по нему можно получить доступ к хранимому значению.

В C\# к значимым типам относятся, например, базовые типы. Поэтому при
объявлении вида
\begin{lstlisting}
int x = 15;
\end{lstlisting}
память под переменную \Lst{x} будет выделена сразу при объявлении, и в
неё будет помещено значение $15.$

Переменная ссылочного типа хранит только ссылку на область памяти, где
располагается значение. При объявлении память выделяется только для
ссылки, а память для значения должна быть выделена отдельно. В языке
C\# для выделения памяти используется операция \Lst{new},
выделяющая область памяти под объект указанного типа и возвращающая
ссылку на неё.

\begin{example}
  Переменная \Lst{x} — ссылка на объект типа
  \Lst{System.Drawing.Bitmap(100, 100)}, соответствующего изображениям
  размера $100\times100$ пикселей.  Переменная \Lst{y} ссылается на
  тот же самый объект, так как была инициализирована ссылкой
  \Lst{x}. В частности, отсюда следует, что изменение \Lst{x} повлечёт
  за собой изменение \Lst{y}.

\begin{lstlisting}
var x = new System.Drawing.Bitmap(100, 100);
var y = x;
\end{lstlisting}
\end{example}

\Par{Сборка мусора}

Операции, позволяющей указать, что некоторая область памяти не
используется и её можно освободить, в C\# нет. Это связано с тем, что
виртуальная машина следит за ссылками на каждую выделенную область
памяти, и если ссылок на какую-то область больше нет, она
освобождается автоматически.  Этим занимается специальная подсистема,
называемая \emph{сборщиком мусора} (GC — garbage collector). Его
поддержка присутствует во многих языках программирования, таких, как
Python, Java, Lisp и т.~д.

Для повышения быстродействия разработчики языка могут отказаться от
сборщика мусора, но в этом случае возникает опасность появления
областей, помеченных как занятые, но не используемых, из-за ошибок
программиста, забывшего вставить команду на освобождение памяти. Такая
ситуация называется \Term{Утечка памяти}{утечкой памяти} (memory
leak).

% пример с null

\Par{Константы}

Если значение переменной не должно меняться во время выполнения
программы, то её можно объявить как константу, добавив перед
объявлением \Lst{const}.

\begin{example}
Константа $g=9{,}81.$

\begin{lstlisting}
const double g = 9.81;
\end{lstlisting}
\end{example}

Константы обязательно должны быть инициализированы, так как в
дальнейшем присвоить им какое-либо значение невозможно.

\section{Виды памяти}

\Par{Иерархия видов памяти}

Из-за технических ограничений, существующих в настоящее время, память
компьютера имеет разнородную структуру. Программы и данные, с которыми
работает компьютер, должны храниться в
\Term{Память!оперативная}{оперативной памяти}. Однако скорость доступа
к ней, как правило, меньше, чем требуется для эффективной работы
процессоров распространённых архитектур. Поэтому большинство машинных
команд предназначено для вычислений над данными, находящимися в особых
ячейках памяти, являющихся частью самого процессора — \Term{Регистр
  процессора}{регистрах}. Их количество ограничено, но доступ к ним
осуществляется за время, сравнимое со временем выполнения одной
команды.

Так как регистров мало, то для ускорения доступа к оперативной памяти,
часто используемые данные из неё копируются в \Term{Кэш
  процессора}{кэш процессора}.  Этот вид памяти работает быстрее, чем
оперативная память, но медленнее, чем регистры. С другой стороны, его
объём больше, чем объём данных, которые можно разместить в регистрах.

Оперативная память достаточно дорога и, как правило, требует
непрерывного электропитания, поэтому большие объёмы данных хранят во
внешней памяти — жёстких дисках, флеш-памяти, оптических дисках и
т.~д.

Таким образом, все рассмотренные виды памяти образуют следующую
иерархию:
\begin{enumerate}
\item регистры (суммарный объём обычно не превышает сотен байт);
\item кэш процессора (до нескольких мегабайт);
\item оперативная память (порядка нескольких гигабайт);
\item внешняя память (объём может значительно отличаться, порядка
  десятков гигабайт — нескольких терабайт).
\end{enumerate}

Этот список упорядочен по возрастанию объёма и уменьшению
быстродействия.

Разница во времени доступа к регистрам и внешней памяти огромна и
может отличаться на несколько порядков.

При написании программ обычно не требуется знать, где расположены
данные: в регистрах, в кэше или оперативной памяти. Компилятор сам
распределяет данные. При прикладном программировании можно условно
считать, что все объекты, с которыми работает программа, располагаются
в оперативной памяти. Впрочем, при написании программ, от которых
требуется высокая скорость расчётов, информация о размещении данных
становится важной.

\Par{Адресное пространство}

Выполнение программы начинается с загрузки её в память операционной
системой. Посое этого программа запускается на выполнение и становится
\Term{Процесс}{процессом}. Одной и той же программе может
соответствовать несколько процессов.

Современные распространённые операционные системы предоставляют
каждому процессу собственное \Term{Пространство!адресное}{адресное
  пространство}. При этом размещение машинных команд и данных
стандартизировано в рамках операционной системы.

На рис.~\ref{fig:memory-map} показана карта виртуального адресного
пространства процесса в операционной системе Linux, выполняющейся на
процессоре архитектуры IA-32.

% http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory
\begin{figure}
  \newcommand{\memsection}[4]{%
    \bytefieldsetup{bitheight=#3\baselineskip}%
    \bitbox[]{10}{%
      \texttt{#1}%
      \\
      \vspace{#3\baselineskip}
      \vspace{-2\baselineskip}
      \vspace{-#3pt}
      \texttt{#2}%
    }%
    \bitbox{28}{#4}%
  }
  
  \begin{bytefield}[bitwidth=0.02\linewidth]{48}
    \begin{rightwordgroup}{1 Гбайт}
      \memsection{ffff ffff}{c000 0000}{6}{Память ядра операционной системы}
    \end{rightwordgroup}\\
    \begin{rightwordgroup}{3 Гбайт}
      \memsection{         }{         }{3}{Стек}\\
      \memsection{         }{         }{3}{↓\\\vspace{\baselineskip}↑}\\
      \memsection{\vphantom{0000 0000}}{4000 0000}{3}{Библиотеки и отображения в память}\\
      \memsection{         }{         }{2}{\vspace{\baselineskip}↑}\\
      \memsection{         }{         }{3}{Куча}\\
      \memsection{         }{         }{3}{Неинициализированные данные}\\
      \memsection{         }{         }{3}{Сегмент данных}\\
      \memsection{\vphantom{0000 0000}}{0804 8000}{3}{Сегмент текста}\\
      \memsection{0804 7fff}{0000 0000}{3}{}
    \end{rightwordgroup}\par
  \end{bytefield}
  
  \caption{Виртуальное адресное пространство процесса\label{fig:memory-map}}
\end{figure}

На практике области, используемые для хранения стека, кучи,
отображений в память, смещают в памяти на случайную величину для
большей безопасности. В разных операционных системах и на разном
аппаратном обеспечении карты адресного пространтва различаются.

Адресное пространство каждого процесса отображается на физическую
память компьютера при помощи как аппаратных средств процессора, так и
механизмов операционной системы. Таким образом, память каждого
процесса становится изолированной от других процессов. Если один
процесс записывает данные по какому-либо адресу, то это никак не
повлияет на данные другого процесса по этому же адресу, но уже в его
адресном пространстве.

В некоторых системах (например, основанных на микроконтроллерах)
поддержки виртуальной памяти нет, поэтому очень важно знать, где и как
располагаются различные части программы.

\Par{Стек}

\begin{defn}
\Term{Стек}{Стек} (англ. stack) как структура данных — это очередь
типа «последний пришёл — первый ушёл» (англ. LIFO, last in — first
out).
\end{defn}

Он поддерживает две основные операции:
\begin{itemize}
\item push — помещение результата на верхушку стека,
\item pop — извлечение значения из верхушки стека.
\end{itemize}
Верхушка стека — это позиция последнего помещённого в него элемента
(или первой свободной ячейки перед ним).

Работа перечисленных операций схематически изображена на
рис.~\ref{fig:stack}.

\begin{figure}
  \begin{centering}
    \begin{tikzpicture}
      \usetikzlibrary{arrows}
      \pgfsetlinewidth{1pt}
      
      % «Стакан»
      \draw (0cm, 4cm) --(0cm, 0cm) --(3cm, 0cm) --(3cm, 4cm);

      % Элементы
      \foreach \y / \n in {0.2cm / 1, 1.2cm / 2, 2.2cm / 3}
      \draw (0.2cm, \y) rectangle  ++(2.6cm, 0.8cm)
      node at ++(-1.3cm, -0.4cm) {Значение \n};

      % Stack Pointer
      \draw[<-] (0cm, 2.6cm) -- ++(-0.5cm, 0cm)
      node[left] {SP};
      
      % Push и Pop
      \draw[<-] (1cm, 3.5cm) to[out=90, in=0] ++(-1cm, 1cm)
      node[left] {Push};

      \draw[->] (2cm, 3.5cm) to[out=90, in=180] ++(1cm, 1cm)
      node[right] {Pop};

    \end{tikzpicture}\par
  \end{centering}
  
  \caption{Организация стека\label{fig:stack}}
\end{figure}

В операционных системах стек используется для хранения переменных,
передачи аргументов в функции и хранения адресов возврата из функций.
Это связано с тем, что стек позволяет сохранить очерёдность выхода из
функций при их вложенном вызове.

Допустим, некоторая функция вызывает другую функцию. В этом случае
она должна поместить аргументы и адрес точки, в которой происходит
вызов, в стек. Существуют и другие соглашения вызова функций, при
которых аргументы передаются через регистры. При написании программы,
содержащей фрагменты, компилируемые различными компиляторами, важно
знать, какие соглашения вызова они используют.

Вызываемая функция размещает в том же стеке свои локальные переменные,
а после завершения также может передать возвращаемое значение через
стек. Удобство стека проявляется в том, что для очистки памяти после
завершения работы вызываемой функции достаточно лишь сместить верхушку
стека на позицию, которую она занимала перед вызовом. При этом не
нужно хранить таблицу областей памяти, используемых вызываемой
функцией.

С другой стороны, у стека есть и недостатки. Например, в нём нельзя
хранить долгоживущие объекты. Если какая-то функция создаёт объект в
стеке, то после выхода из неё он будет уничтожен. Также операционные
системы обычно ограничивают размер стека для предотвращения его
неограниченного роста и повреждения других данных.

Из-за перечисленных недостатков данные кроме стека размещается также
и в области памяти, называемой кучей.

В языке C\# стек как правило используется для хранения объектов
значимого типа и ссылок на объекты в куче.

\Par{Куча}

\begin{defn}
\Term{Куча}{Куча} (англ. heap) — область памяти, предназначенная для
хранения произвольных объектов, создаваемых программой.
\end{defn}

Хоть куча и хранит произвольные объекты, она не является
неструктурированной областью памяти. Должен вестись учёт объектов и
областей памяти, занимаемых ими. Куча должна позволять выделять память
под произвольные объекты, то есть указывать на области памяти, не
занятые другими объектами.

Так как время жизни объекта (то есть, время до пометки занимаемой им
памяти как свободной) не регламентируется, то возникает проблема
фрагментированности памяти. Иными словами, в какой-то момент в памяти
может не оказаться единого свободного фрагмента нужного размера, хотя
суммарный объём всех свободных областей может быть больше требуемого
объёма.

Кроме того, программа сама должна контролировать время жизни объектов.
Она должна удалять объекты, которые больше не используются, из кучи и
помечать занимаемую ими область памяти, как свободную. Во многих
языках программирования (и в платформе .NET, в частности) процесс
удаления автоматизирован — им занимается сборщик мусора.

В языке C\# объекты создаются в куче при помощи операции
\Lst{new}. При этом, ссылка на объект обычно сохраняется в стеке. Если
на объект не остаётся ссылок, то он уничтожается.

\Par{Домены приложений}

Изоляция процессов друг от друга упрощает программирование и делает
работу операционной системы более безопасной, но вносит дополнительные
сложности, если процессы должны взаимодействовать между собой.

В платформе .NET проблема взаимодействия процессов решается при помощи
\Term{Домен приложения}{доменов приложений}. Это механизм, позволяющий
запустить песколько приложений в рамках одного процесса. Очевидно, они
могут иметь разделяемые данные, так как работают в одном и том же
адресном пространстве. С другой стороны, среда выполнения CLR
инспектирует код выполняющихся приложений и обеспечивает их
изолированность друг от друга.

Программный код, который может быть безопасно (с точки зрения выхода
за границы домена) выполнен, называется
\Term{Код!безопасный}{безопасным}. Платформа .NET также позволяет
выполнять и небезопасный код, но в этом случае ответственность за
целостность данных ложится на программиста.
